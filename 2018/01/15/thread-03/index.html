<!DOCTYPE HTML>
<html>
<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://yoursite.com">
    <!--SEO-->



<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->


<title>Java线程、线程池、并发包(3) | 独一无二</title>


    <link rel="alternate" href="/atom.xml" title="独一无二" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    

    
                <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.4/css/bootstrap.min.css?rev=3.3.4">
<link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">
    
    <div class="hide">
    	<script src="https://s4.cnzz.com/z_stat.php?id=1263868967&web_id=1263868967" language="JavaScript"></script>
    </div>






    
</head>


<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(
    http://7xpw2b.com1.z0.glb.clouddn.com/hexo-sinppet/img/banner2.jpg)"
         >
            <div class="main-header-box">
                <a class="header-avatar" href="/" title="">
                    <img src="/img/avatar.jpg" alt="logo头像">
                </a>
                <div class="branding">
                    <!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
                    
                            <img src="/img/branding2.png" alt="Snippet 博客主题">
                                
                </div>
            </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only">Toggle navigation</span>
                    <i class="fa fa-bars"></i>
                    </span>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" path=""><a href="/"><i class="fa fa-fw "></i>首页</a>
                            </li>
                            
                            <li role="presentation" path="/前端/"><a href="/categories/"><i class="fa fa-fw "></i>前端</a>
                            </li>
                            
                            <li role="presentation" path="/后端/"><a href="/categories/"><i class="fa fa-fw "></i>后端</a>
                            </li>
                            
                            <li role="presentation" path="/工具/"><a href="/categories/工具/"><i class="fa fa-fw "></i>资源工具</a>
                            </li>
                            
                            <li role="presentation" path="/about/"><a href="/about/"><i class="fa fa-fw "></i>关于作者</a>
                            </li>
                            
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="Java线程、线程池、并发包(3)">
            
            Java线程、线程池、并发包(3)
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <span>语言基础</span>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            多线程
            
        </span>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">2018/01/15</span>
    </span>
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <h2 id="1-线程池-java-util-concurrent"><a href="#1-线程池-java-util-concurrent" class="headerlink" title="1.线程池(java.util.concurrent)"></a>1.线程池(java.util.concurrent)</h2><p>为什么要有线程池 ？</p>
<p>我们知道。使用线程来处理任务，可以达到一定程度的并行计算的效果，在一些比较耗时的操作时候不用一直等待，比如以下i/o操作。那么每次需要的时候就创建一个线程来处理这种任务就好了，为什么要引入线程池这个概念呢？</p>
<p>主要存在三方面的原因：</p>
<ol>
<li><strong>线程生命周期的开销非常高。</strong> 创建线程是需要时间的，并且需要JVM和底层操作系统提供一些辅助的支持，无限创建线程，必定在创建线程的时候消耗很多资源。</li>
<li><strong>资源消耗。</strong> 活跃的线程必定要占据一定的内存，线程越多，使用的内存越大。当可运行的线程多于可用的处理器数量的时候，线程就会闲置。大量的闲置线程就会占据大量内存，给垃圾回收带来很多的压力。而且这些线程在资源CPU竞争的时候也将产生更大的开销。</li>
<li><strong>稳定性。</strong> 之前的JVM的OOM中有提到过，过多的线程还会可能出现OOM异常。因为线程数量受制于JVM的参数配置，Thread构造方法中的请求栈大小，以及底层操作系统对线程的闲置，一旦超出就会出现OOM的异常</li>
</ol>
<p>所以，使用线程池，用它来管理线程，可以有效的减少因为线程创建和线程数量过多导致的问题</p>
<h2 id="1-1-Executor框架"><a href="#1-1-Executor框架" class="headerlink" title="1.1 Executor框架"></a>1.1 Executor框架</h2><h3 id="1-1-1-框架基础"><a href="#1-1-1-框架基础" class="headerlink" title="1.1.1 框架基础"></a>1.1.1 框架基础</h3><p>先来看看住基本的框架结构图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4752922-cb11c80a4616ee27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="executor"></p>
<p><strong>1. 主要元素：</strong></p>
<ol>
<li>顶层是一个Executor接口，主要常用的实现类是ThreadPoolExecutor和ScheduledThreadPoolExecutor</li>
<li>BlockingQueue接口及其实现</li>
<li>Future接口以及实现</li>
<li>Executors 创建线程池的关键类</li>
</ol>
<p><strong>2. 框架执行原理</strong></p>
<p>关于执行原理，说到这个问题，不得不说jdk源码的作者写代码真是习惯好，跟进源码，查看Executor接口，在类上面，很大段的解释和说明，还有示例代码来说明。相比周围的我们写的代码，简简单单的几行注释，甚至有的完全写出来就是没有注释，试问这样代码怎么看。很多时候我觉得写代码好不好，代码风格和格式很重要。</p>
<p>回答我们刚才的话题，一起来看看Executor接口上面的注释吧 </p>
<p><strong>2.1 Excutor接口</strong></p>
<p>我们去看源码就发现，<code>Executor</code>接口只有个方核心方法<code>execute</code>,接收的参数是<code>Runnable</code>。Runnable在jdk里面，我们都称之为Task也就是要执行的任务，使用Executor可是避免我们反复的使用<code>new Thread(new(RunnableTask())).start()</code>。当有很多任务需要执行的时候，可以如下的方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步执行任务</span></span><br><span class="line"> Executor executor = anExecutor; <span class="comment">// 此处伪代码，实现时候就是使用Executors创建一个子类</span></span><br><span class="line"> executor.execute(<span class="keyword">new</span> RunnableTask1());</span><br><span class="line"> executor.execute(<span class="keyword">new</span> RunnableTask2());</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure></p>
<p>上面的代码，会使得多个任务异步的执行。在executor源码注释上有写明，这个接口也可以不要求任务是异步执行的，一个简单例子就是直接执行提交的任务的run方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接同步执行</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        r.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是更典型的方式使用一个线程来执行任务而不是使用run方法，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个任务一个线程异步去执行</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而在Executor框架中，<code>Executor</code>的实现类都是解决的批量任务的执行顺序和时间的问题。下面的例子是一个顺序执行的Executor的一个实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多任务顺序执行</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Queue&lt;Runnable&gt; tasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">    <span class="keyword">final</span> Executor executor;</span><br><span class="line">    Runnable active;</span><br><span class="line"></span><br><span class="line">    SerialExecutor(Executor executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">        tasks.offer(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    scheduleNext();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (active == <span class="keyword">null</span>) &#123;</span><br><span class="line">            scheduleNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((active = tasks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            executor.execute(active);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这个例子基本能简单表现出执行任务的思路，值得注意的一点就是，这个jdk注释中的例子在executor中引入了一个任务队列，再把队列中的任务取出顺序执行。在JDK提供的Executor的实现类中，使用workQueue来存储需要执行的任务，使用一个Worker集合works来执行任务（不同于上例中的顺序执行，且上例中工作线程相当于只有一个）。执行Worker启动后执行完自己的runnable后还会从workQueue中继续获取任务执行，直到任务队列为空。</p>
<p><strong>2.2 ExecutorService 接口</strong></p>
<p>ExecutorService接口继承自Executor 接口，主要增加了线程生命周几管理的几个方法以及Future 来跟踪任务一个或多个异步任务的处理情况。</p>
<p>其中</p>
<ol>
<li>shutDown() 关闭executor，已经提交的任务会被执行，新的任务不会再接受 </li>
<li>shutDownNow() 立即关闭executor,停止执行，并返回一个等待执行的任务列表</li>
<li>isShutDown() executor是否终止</li>
<li>isTerminated() 所有任务执行完成，只有在调用了shutDown或者shutDownNow之后，才会返回true</li>
<li>submit() 几种提交任务的方式 </li>
</ol>
<p><strong>2.3 Executors</strong></p>
<p>提供各种方法创建线程池，从大的方向看，线程主要分为两类，一种就是不同的异步执行的，一种就是实现了ScheduledExecutorService 接口的线程，两类线程的区别在于在于ScheduledExecutorService是那种有计划执行的任务，比如说定时任务或者延时执行的任务。</p>
<p>具体使用查看Executors.newXXX() 相关文档</p>
<h3 id="1-1-2-ThreadPoolExecutor-amp-ScheduledThreadPoolExecutor"><a href="#1-1-2-ThreadPoolExecutor-amp-ScheduledThreadPoolExecutor" class="headerlink" title="1.1.2. ThreadPoolExecutor &amp; ScheduledThreadPoolExecutor"></a>1.1.2. ThreadPoolExecutor &amp; ScheduledThreadPoolExecutor</h3><p>ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 都是executorService的实现类，他们关系从之前类图已经可以清楚地看出来。基本使用差不多，却别就在于定位或者延时功能。所以本文只分析ThreadPoolExecutor的源码，来看看线程池的工作大致流程。</p>
<h4 id="1-1-2-1-ThreadPoolExecutor源码分析"><a href="#1-1-2-1-ThreadPoolExecutor源码分析" class="headerlink" title="1.1.2.1 ThreadPoolExecutor源码分析"></a>1.1.2.1 ThreadPoolExecutor源码分析</h4><p>在分析源码前，我根据个人的理解，先简单说明线程池工作的流程，在进入代码查看。</p>
<p>之前在看JDK的Executor接口的文档的时候，在源码上面的标准注释里面的例子（也是生成的javadoc里面的注释）的最后一个，有提到过一个概念，<strong>任务队列</strong>。前文还简单说了下具体实现类和那个例子的不同。现在来具体看看，在说之前，先明白几个概念。</p>
<ol>
<li>工作队列 <code>BlockingQueue&lt;Runnable&gt; workQueue</code>。存放所有的runnable任务。</li>
<li>工作线程集合 <code>HashSet&lt;Worker&gt; workers</code>。线程池中所有的工作线程集合</li>
</ol>
<p>Runnable都清楚是什么，Woker呢，先看看worker类可能更能方便理解线程池的工作过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Woker</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">         * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">        <span class="keyword">final</span> Thread thread;</span><br><span class="line">        <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">        Runnable firstTask;</span><br><span class="line">        <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">            <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            runWorker(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p>很明显就是有个线程，一个任务，和任务完成数量，核心方法是runWorker</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runWorker</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">                <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">                <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">                <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>runWorker做的事情很明确，如果Worker创建的时候带了任务，则执行这个任务的run()方法，如果没有就去执行getTask()在workQueue中获得一个任务来执行，直到没任务可执行为止。</p>
<p>在回头看execute方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">         * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">         * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">         * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">         * threads when it shouldn't, by returning false.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">         * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">         * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">         * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">         * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">         * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">         * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">         * and so reject the task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这段执行逻辑：</p>
<ol>
<li>查看当前Worker(工作线程)数量有没有达到coreSize,没有就创建一个工作线程</li>
<li>如果线程池没有关闭，并且添加到队列成功，再次执行下检测，或者拒绝，或者由于工作线程没有重新添加工作线程。这个分支需要注意的是，可能这个分支走完只添加了任务，没有添加线程。也就是重复利用线程。利用已有的工作线程自己去队列中消费任务。例外注意runWorker里面使用的getTask() 实际是个阻塞的，一直循环在取队列中的任务，取不到一直循环，这个线程就会一直在。runWorker也是个死循环一直执行task.run。所以线程中的线程其实一直在运行的。但是getActiveCount 是去HashSet<worker> workers 里面的上锁(在执行run的线程，而不是在getTask的)的线程数量。</worker></li>
<li>添加任务失败的时候，直接拒绝</li>
</ol>
<p>这里另外说一下，。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addWorker 部分代码</span></span><br><span class="line">...</span><br><span class="line">w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line"> <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">        t.start();</span><br><span class="line">        workerStarted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>addWorker最后会启动worker的私有属性thread的线程，开始执行runWorker,同事把worker添加到HashSet<worker>中<br>由于worker的构造函数中<code>this.thread = getThreadFactory().newThread(this);</code> 所以woker的thread启动的时候，执行的就是Wroker的run，即threadPoolExecutor的runWorker方法。整个执行链如下：</worker></p>
<p><code>ThreadPoolExecutor.execute()--&gt;addWorkder(可能添加成功或者失败，失败是涉及到拒绝处理问题)--&gt;Workder.thread.start()--&gt;Worker.run--&gt;threadPoolExecutor.runWorker--&gt;循环执行getTask、task.run</code></p>
<p>以上就是线程基本的执行流程了，观察ThreadPoolExecutor的完整参数的构造方法发现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br></pre></td></tr></table></figure></p>
<p>其中ThreadFactory 是用来创建Worker的thread用的，管理所有的线程。<br>RejectedExecutionHandler handler是在addWorker的时候如果添加失败，执行的饱和策略。JUC(java.util.concurrent)包中有提供几种实现。也可以根据需要自己实现自己的饱和策略。</p>
<h4 id="1-1-2-2-Exexutors-newXXX的参数意义和是使用时候注意的问题"><a href="#1-1-2-2-Exexutors-newXXX的参数意义和是使用时候注意的问题" class="headerlink" title="1.1.2.2 Exexutors.newXXX的参数意义和是使用时候注意的问题"></a>1.1.2.2 Exexutors.newXXX的参数意义和是使用时候注意的问题</h4><ol>
<li><p><strong>newFixedThreadPool</strong><br>创建一个固定长度的线程池，每次提交任务就会创建线程，知道达到最大线程数。如果线程发生Exception死掉，会新补充线程进来。默认工作队列最大长度是Integer.MXA_VALUE。认为是一个无界的队列</p>
</li>
<li><p><strong>newCachedThreadPool</strong><br>创建一个可缓存的线程池，如果线程池的当前规模超出了处理需求，就回收空闲线程，如果需求增加就添加新的线程。线程值规模不受限制，所以在使用的时候，操作不当可能创建很多线程导致OOM。<br>使用的队列是SynchronousQueue.</p>
</li>
<li><p><strong>newScheduledThreadPool</strong><br>创建固定长度线程池，而且以延迟或定时的方式来执行任务</p>
</li>
<li><p><strong>newSingleThreadExecutor、newSingleThreadScheduledExecutor</strong><br>创建一个单线程的Executor，如果单个线程出现Exeception死掉，就是创建一个线程来替代。他可以确保任务队列中的任务是顺序执行的。</p>
</li>
</ol>
<h2 id="1-2-线程池任务管理-Queue-amp-Deque"><a href="#1-2-线程池任务管理-Queue-amp-Deque" class="headerlink" title="1.2. 线程池任务管理 Queue &amp; Deque"></a>1.2. 线程池任务管理 Queue &amp; Deque</h2><p>ThreadPoolExecutor提供了三中队列方式：无界队列、有界对列、同步移交。队列的选择与其他的参数有关，例如：线程池的大小。</p>
<p><strong>无界、有界队列</strong>。使用无界队列当线程池中的线程都处于忙碌状态的时候，工作队列就会无限制的增长。一种更加稳妥的方式使用有界队列，例如：ArrayBlockingQueue，有界LinkedBlockingQueue，PriorityBlockingQueue。有界队列有助于避免资源耗尽情况的发生，但是就需要考虑队列填满时候的饱和策略问题。</p>
<p><strong>同步移交</strong>。对于非常大或者无界的线程池，可以使用SynchronousQueue来避免任务排队，以及直接将任务从生产者直接移交给工作线程，移交的时候必须要求有线程等待接受，如果没有切线程池线程数小于最大线程，就创建线程接受，否则就拒绝。</p>
<p><strong>执行顺序</strong> 。ArrayBlockingQueue 和 PriorityBlockingQueue是FIFO类型队列，如果想进一步的控制任务执行的顺序，可以使用PriorityBlockingQueue来进行管理，任务优先级是通过自然顺序或者Comparator接口来定义的。</p>
<p><strong>注意：只有当任务相互独立是，为线程池或者工作队列设置界限才是合理的，如果任务之间存在依赖，那么有界的线程池或者队列就可能导致“饥饿”死锁问题</strong></p>
<h2 id="1-3-线程池饱和策略-RejectedExecutionHandler"><a href="#1-3-线程池饱和策略-RejectedExecutionHandler" class="headerlink" title="1.3 线程池饱和策略 RejectedExecutionHandler"></a>1.3 线程池饱和策略 RejectedExecutionHandler</h2><p>当有界队列被填满的时候，饱和策略就开始发挥作用了。ThreadPoolExecutor的饱和策略可以通过调用setRejectedExecutionHandler来修改。JDK提供了四种默认的饱和策略。</p>
<p><strong>AbortPolicy</strong> 默认策略，抛出一个未经检测的RejectedExecutionException,调用者捕获这个异常，根据自己的需求编写自己的代码。</p>
<p><strong>DiscardPolicy</strong> 抛弃策略， 当新的任务无法添加到队列的时候，默默的抛弃该任务</p>
<p><strong>DiscardOldestPolicy</strong> 抛弃最早策略，次策略会抛弃写一个要执行的任务，然后尝试提交任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">        e.getQueue().poll();</span><br><span class="line">        e.execute(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此如果是个优先队列，则抛弃优先级最高的策略，所有不建议这个策略和优先队列一起使用</p>
<p><strong>CallerRunsPolicy</strong> 调用者直接执行run策略，这种直接在调用者的线程执行任务的run方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">        r.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为直接下调用者里面执行的任务，所有会是一个同步的效果，就会带来响应的延时。</p>
<p>以上四种是JDK提供的策略，我们还可以根据自己的需要，自己实现RejectedExecutionHandler，实现我们自己的饱和策略。</p>
<h2 id="1-4-线程池如何重复利用线程的-？"><a href="#1-4-线程池如何重复利用线程的-？" class="headerlink" title="1.4 线程池如何重复利用线程的 ？"></a>1.4 线程池如何重复利用线程的 ？</h2><h3 id="1-4-1-ThreadFactory"><a href="#1-4-1-ThreadFactory" class="headerlink" title="1.4.1 ThreadFactory"></a>1.4.1 ThreadFactory</h3><p>线程工厂是创建线程的地方，实际就是创建工作线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultthreadFactory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                          namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                          <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">        t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">        t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-2-线程池如何重复利用线程？"><a href="#1-4-2-线程池如何重复利用线程？" class="headerlink" title="1.4.2 线程池如何重复利用线程？"></a>1.4.2 线程池如何重复利用线程？</h3><p>通过前面对线程池的理解，线程池的实现思路基本有一定的了解，那么线程池究竟如何重复利用线程的呢？</p>
<p>其实这里的“重复” 并没有放开重新获取，而是工作线程一直运行。当运行的线程数量没有达到coreSize的时候，不管任务多少，新来任务会重新创建工作线程。工作线程中执行的是死循环一直获取任务来执行。通过使用工作线程来执行任务的run方法达到避免创建线程的目的。前面源码分析部分，查看execute、addWorker、runWorker、getTask 四个方法就很明了。</p>
<ol>
<li>execute: 添加工作线程，或者只添加任务、或者拒绝任务</li>
<li>addWorker: 实际上的创建工作线程，并start</li>
<li>runWorker: 工作线程的run方法里面执行的代码，循环取队列的中的任务进行执行。</li>
<li>getTask: 一直去任务，队列为空就一直循环直到取到值或者线程池关闭。</li>
</ol>
<p>所以线程池的工作线程一点启动，是一直在运行的。没有任务可执行的时候，也是在执行，只不过这个时候是阻塞在了getTask方法中。所以千万不要理解成线程池做完任务就把线程放回去，要用的时候在拿出来。</p>

    </div>

    <div class="post-footer">   
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Snippet</a>
            
        </div>
        <div>
            
        </div>  
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2018/01/16/thread-04/" class="pre-post btn btn-default"><i class="fa fa-angle-left fa-fw"></i>上一篇</a>
    
    
        <a href="/2018/01/14/thread-02/" class="next-post btn btn-default">下一篇<i class="fa fa-angle-right fa-fw"></i></a>
    
</div>


    <div id="comments">
        
    <div id="uyan_frame"></div>
    <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2154669"></script>
    
    </div>





                </main>
                
    <aside class="col-md-4 sidebar">
        
        
    <div class="widget">    
        <h3 class="title">搜索</h3>
        <div id="search-form">
            <div id="result-mask" class="hide"></div>
            <div class="search-area">
                
                    <input id="search-key" type="search" autocomplete="off" placeholder="搜点什么呢?">
                    <button type="button" class="search-form-submit" id="search-local">站内搜索</button>
                
                
            </div>
            <div id="result-wrap" class="hide">
                <div id="search-result"></div>
            </div>
            <div class="hide">
                <template id="search-tpl">
                    <div class="item">
                        <a href="/{path}" title="{title}">
                            <div class="title">{title}</div>
                            <div class="content">{content}</div>
                        </a>
                    </div>
                </template>
            </div>
        </div>
    </div>

        
        
    <div class="widget">
        <h3 class="title">分类</h3>
        <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/工具/"><i class="fa" aria-hidden="true">工具</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link current" href="/categories/语言基础/"><i class="fa" aria-hidden="true">语言基础</i></a><span class="category-list-count">9</span></li></ul>
    </div>


        
        
    <div class="widget">
      <h3 class="title">归档</h3>
        <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/"><i class="fa" aria-hidden="true">一月 2018</i></a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/"><i class="fa" aria-hidden="true">四月 2017</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/"><i class="fa" aria-hidden="true">三月 2017</i></a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/"><i class="fa" aria-hidden="true">二月 2017</i></a><span class="archive-list-count">1</span></li></ul>
    </div>


        
        
  <div class="widget">
    <h3 class="title">标签云</h3>
    <div class="content tag-cloud">
        <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/static/" style="font-size: 10px;">static</a> <a href="/tags/内部类/" style="font-size: 10px;">内部类</a> <a href="/tags/多线程/" style="font-size: 20px;">多线程</a> <a href="/tags/并发包/" style="font-size: 10px;">并发包</a> <a href="/tags/序列化/" style="font-size: 10px;">序列化</a> <a href="/tags/线程池/" style="font-size: 10px;">线程池</a> <a href="/tags/集合类/" style="font-size: 10px;">集合类</a>
    </div>
  </div>


        
        
    <div class="widget">
      <h3 class="title">社交</h3> 
        <div class="content social">
            
	            <a href="//github.com/funye" rel="external nofollow" title="Github" target="_blank">
			    	<i class="git fa fa-git"></i>
			    </a>
            
	            <a href="mailto:fun913510024@163.com" rel="external nofollow" title="邮箱" target="_blank">
			    	<i class="envelope-o fa fa-envelope-o"></i>
			    </a>
            
	            <a href="/" rel="external nofollow" title="联系QQ" target="_blank">
			    	<i class="qq fa fa-qq"></i>
			    </a>
            
	            <a href="/" rel="external nofollow" title="微博" target="_blank">
			    	<i class="weibo fa fa-weibo"></i>
			    </a>
            
	            <a href="/" rel="external nofollow" title="QQ群" target="_blank">
			    	<i class="users fa fa-users"></i>
			    </a>
            
	            <a href="/atom.xml" rel="external nofollow" title="RSS" target="_blank">
			    	<i class="feed fa fa-feed"></i>
			    </a>
            
        </div>
    </div>


        
        
    <div class="widget">
        <h3 class="title">友链</h3>
        <div class="content friends-link">
        
            <a href="https://github.funye.io" class="fa" target="_blank">个人博客</a>
        
        </div>
    </div>


        
    </aside>

            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12"> 
                <span>Copyright &copy; 2018
                </span> | 
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> | 
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>


    <script src="/js/search.js?rev=@@hash"></script>
        

            <script src="/js/app.js?rev=@@hash"></script>

</body>
</html>