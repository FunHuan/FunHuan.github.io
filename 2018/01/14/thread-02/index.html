<!DOCTYPE HTML>
<html>
<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://yoursite.com">
    <!--SEO-->



<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->


<title>Java线程、线程池、并发包(2) | 独一无二</title>


    <link rel="alternate" href="/atom.xml" title="独一无二" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    

    
                <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.4/css/bootstrap.min.css?rev=3.3.4">
<link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">
    
    <div class="hide">
    	<script src="https://s4.cnzz.com/z_stat.php?id=1263868967&web_id=1263868967" language="JavaScript"></script>
    </div>






    
</head>


    <!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->


        <body>
            <header class="main-header"  style="background-image:url(
    http://7xpw2b.com1.z0.glb.clouddn.com/hexo-sinppet/img/banner2.jpg)"
         >
            <div class="main-header-box">
                <a class="header-avatar" href="/" title="">
                    <img src="/img/avatar.jpg" alt="logo头像">
                </a>
                <div class="branding">
                    <!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
                    
                            <img src="/img/branding2.png" alt="Snippet 博客主题">
                                
                </div>
            </div>
</header>
                <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only">Toggle navigation</span>
                    <i class="fa fa-bars"></i>
                    </span>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" path=""><a href="/"><i class="fa fa-fw "></i>首页</a>
                            </li>
                            
                            <li role="presentation" path="/前端/"><a href="/categories/"><i class="fa fa-fw "></i>前端</a>
                            </li>
                            
                            <li role="presentation" path="/后端/"><a href="/categories/"><i class="fa fa-fw "></i>后端</a>
                            </li>
                            
                            <li role="presentation" path="/工具/"><a href="/categories/工具/"><i class="fa fa-fw "></i>资源工具</a>
                            </li>
                            
                            <li role="presentation" path="/about/"><a href="/about/"><i class="fa fa-fw "></i>关于作者</a>
                            </li>
                            
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
                    <section class="content-wrap">
                        <div class="container">
                            <div class="row">
                                <main class="col-md-9 main-content m-post">
                                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="Java线程、线程池、并发包(2)">
            
                    Java线程、线程池、并发包(2)
                        
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <span>语言基础</span>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            多线程
            
        </span>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">2018/01/14</span>
    </span>
</div>

            
                
    </div>
    
        <div class="post-body post-content">
            <h2 id="java的线程Thread"><a href="#java的线程Thread" class="headerlink" title="java的线程Thread"></a>java的线程Thread</h2><blockquote>
<p>现在的操作系统是多任务操作系统。多线程是实现多任务的一种方式。</p>
<p>进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程中可以启动多个线程。比如在Windows系统中，一个运行的exe就是一个进程。</p>
<p>线程是指进程中的一个执行流程，一个进程中可以运行多个线程。比如java.exe进程中可以运行很多线程。线程总是属于某个进程，进程中的多个线程共享进程的内存。</p>
</blockquote>
<p>引用网上对线程的一个说法，个人觉得比较的形象</p>
<h2 id="1-1-线程的创建和启动"><a href="#1-1-线程的创建和启动" class="headerlink" title="1.1 线程的创建和启动"></a>1.1 线程的创建和启动</h2><h3 id="1-1-1-线程创建"><a href="#1-1-1-线程创建" class="headerlink" title="1.1.1 线程创建"></a>1.1.1 线程创建</h3><p>创建线程方式主要有两个：</p>
<ol>
<li>继承Thread类，利用构造方法创建一个线程</li>
<li>实现Runnable接口。在利用带Runnable参数的构造方法</li>
</ol>
<p>看例子：</p>
<p><strong>1. 实现Thread类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> minPrime;</span><br><span class="line">        PrimeThread(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">            <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">             . . .</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">PrimeThread p = <span class="keyword">new</span> PrimeThread(<span class="number">143</span>);</span><br><span class="line">p.start();</span><br></pre></td></tr></table></figure>
<p><strong>2. 实现Runnable 接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">PrimeRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">         <span class="keyword">long</span> minPrime;</span><br><span class="line">         PrimeRun(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">             <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">              . . .</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">PrimeRun p = <span class="keyword">new</span> PrimeRun(<span class="number">143</span>);</span><br><span class="line">     <span class="keyword">new</span> Thread(p).start();</span><br></pre></td></tr></table></figure>
<h3 id="1-1-2-Thread和Runnable"><a href="#1-1-2-Thread和Runnable" class="headerlink" title="1.1.2 Thread和Runnable"></a>1.1.2 Thread和Runnable</h3><p>看了上面分别使用继承的方式和runnable接口的方式，那他们又有何不同呢</p>
<p>其实看看两者的代码区别就知道了，如果继承的话，每次new Thread创建一个新的线程，然而runnable的方式虽然也是每次new Thread() ，但是，<strong>构造方法中的runnable可以是同一个也可以是每次new一个</strong>。这点可以有很大的区别，可以很好利用</p>
<p>假如我们线程有个自己的私有成员，对应使用继承Thread 的方式，每次new ,这个私有成员一定是自己所有的。但是使用runnable的话，就不一定了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.fun.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现runnable接口的任务类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2017-03-13 21:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> taskId;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 可以做共享变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestTask</span><span class="params">(<span class="keyword">int</span> taskId,<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskId = taskId;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"taskId is:"</span>+taskId+<span class="string">" , count is:"</span>+count);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"threadId: "</span>+Thread.currentThread().getId()+</span><br><span class="line">                    <span class="string">", threadName: "</span>+Thread.currentThread().getName()+</span><br><span class="line">                    <span class="string">",isDaemon "</span> + Thread.currentThread().isDaemon());</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            count--;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码是一个实现runnable接口的任务。请看在使用时候的区别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">// 1. 每个线程都有一个新的Runnable</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> TestTask(i + <span class="number">1</span>, <span class="number">10</span>)).start();</span><br><span class="line">			Thread.sleep(<span class="number">200</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span>  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		TestTask testTask = <span class="keyword">new</span> TestTask(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(testTask).start();</span><br><span class="line">			Thread.sleep(<span class="number">200</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>上面结果</p>
<ol>
<li>test1中，每次new TestTask传递给Thread,所以打印的都是count=10</li>
<li>test2中，每个Thread其实都是用的一个runnable构造，这个时候他们共享TestTask的count值。打印的count减小了</li>
</ol>
<p>所以这里可以利用这个特点处理共享资源，只要合理加锁，就可以处理好共享资源，如上面count加上volatile 保证可见性，再count– 加块级锁就ok</p>
<h3 id="1-1-3-线程启动"><a href="#1-1-3-线程启动" class="headerlink" title="1.1.3 线程启动"></a>1.1.3 线程启动</h3><p>之前也有代码使用过线程，线程启动一般使用 start() 或者 run() 但是一般建议是start()</p>
<p>为什么建议使用start() ?</p>
<p><strong>其实使用run()和start()，最终都是调用的run,最重要的区别在于，执行方法的线程是谁。<br>使用 start() 方法，是新建立的线程在执行，然而使用run()时候，是run()调用处的线程</strong>（如果在主线程直接调用了run() ,操作run()的线程就是main,并不是生成的新的线程）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRunAndStartDiff</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">"main threadId: "</span>+Thread.currentThread().getId()+</span><br><span class="line">					<span class="string">",main threadName: "</span>+Thread.currentThread().getName()+</span><br><span class="line">					<span class="string">",isDaemon "</span> + Thread.currentThread().isDaemon());</span><br><span class="line">	Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> TestTask(<span class="number">1</span>,<span class="number">10</span>));</span><br><span class="line">	t.start();</span><br><span class="line"></span><br><span class="line">	Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> TestTask(<span class="number">2</span>,<span class="number">20</span>));</span><br><span class="line">	t2.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main threadId: <span class="number">1</span>,main threadName: main,isDaemon <span class="keyword">false</span></span><br><span class="line">taskId is:<span class="number">2</span> , count is:<span class="number">20</span></span><br><span class="line">threadId: <span class="number">1</span>, threadName: main,isDaemon <span class="keyword">false</span></span><br><span class="line">taskId is:<span class="number">1</span> , count is:<span class="number">10</span></span><br><span class="line">threadId: <span class="number">11</span>, threadName: Thread-<span class="number">0</span>,isDaemon <span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>可以看到 Task 2 是用的run() ,实际上是ThreadId=1 的线程执行的（main）<br>Task1 是自己生成的线程（ThreadId=11）执行的</p>
<p>所以，注意是谁执行自己，在多线程处理的时候，取Thread.currentThread()注意，是start()启动还是run启动</p>
<p>生活一个开关我们打开了，自己有可能把它关掉在打开。同样，如果一个线程start()之后，我还可以拿着这个Thread 在开始一次吗</p>
<p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMultiCallStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> TestTask(<span class="number">1</span>,<span class="number">10</span>));</span><br><span class="line">	t.start();</span><br><span class="line">	t.start(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">测试结构是不能再次调用start，直接报java.lang.IllegalThreadStateException</span><br></pre></td></tr></table></figure></p>
<p>跟进start() 方法源码就会发现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br></pre></td></tr></table></figure></p>
<p>start()之前会先判断线程状态,但是如果用 t.run() 是可以多次调用的。也算是start() 和 run()的区别吧 ，<strong>因为直接调用run()其实都没有新建线程</strong></p>
<p>说到线程状态，那么来看看线程的状态到底有哪些？</p>
<h2 id="1-2-线程状态"><a href="#1-2-线程状态" class="headerlink" title="1.2 线程状态"></a>1.2 线程状态</h2><h3 id="1-2-1-线程状态分析"><a href="#1-2-1-线程状态分析" class="headerlink" title="1.2.1 线程状态分析"></a>1.2.1 线程状态分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">         * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">         * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">         * such as processor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">         * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">         * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">         * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">         * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">         * following methods:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">         * perform a particular action.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">         * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">         * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">         * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">         * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">         * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">         * The thread has completed execution.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>NEW</strong> 创建完成，但是没有启动</li>
<li><strong>RUNABLE</strong> 运行状态。正在java虚拟中被执行，但是有可能正在等待系统资源，比如处理器资源</li>
<li><strong>BLOCKED</strong> 受阻塞，并在等待监视器锁。线程正在等待监视器锁，以便进入同步方法/块，或者这调用Object.wait()方法后再次进入同步方法/块</li>
<li><strong>WAITING</strong> 等待中，线程调用如下方法会进入等待状态<ol>
<li>Object.wait()并且没有超时时间</li>
<li>Thread.join() 并且没有超时时间</li>
<li>LockSupport.park()</li>
</ol>
</li>
</ol>
<p>例如：已经在某一对象上调用了 Object.wait() 的线程正等待另一个线程，以便在该对象上调用 Object.notify() 或 Object.notifyAll()。</p>
<ol>
<li><strong>TIMED_WAITING</strong> 指定等待时间的等待，调用如下方法会进入此状态<ol>
<li>Thread.sleep()</li>
<li>Object.wait() 指定超时时间</li>
<li>Thread.join() 执行超时时间</li>
<li>LockSupport.parkNanos</li>
<li>LockSupport.parkUntil</li>
</ol>
</li>
<li><strong>TERMINATED</strong> 线程结束，完成执行</li>
</ol>
<h3 id="1-2-2-线程状态转换图"><a href="#1-2-2-线程状态转换图" class="headerlink" title="1.2.2 线程状态转换图"></a>1.2.2 线程状态转换图</h3><p>线程状态之间的转换图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4752922-3119da8ae7ae0613.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线程状态转换图"></p>
<h2 id="1-3-关于守护线程-Daemon-Thread"><a href="#1-3-关于守护线程-Daemon-Thread" class="headerlink" title="1.3 关于守护线程 Daemon Thread"></a>1.3 关于守护线程 Daemon Thread</h2><p>java中的线程分为两类：<strong>用户线程(User Thread)、守护线程(Daemon Thread)</strong></p>
<p>守护线程就是程序运行的时候在后台提供一种通用的服务的线程。比如：垃圾回收线程。这种线程并不是程序中不可或缺的，因此，<strong>当所有的非守护线程结束时候，程序也会终止，同时会杀死进程中所有的守护线程</strong>。</p>
<p>用户线程和守护线程几乎没有什么区别，唯一的不同之处在于虚拟机的离开：如果所有的用户线程结束了，守护线程没有守护对象，程序还是会结束。</p>
<p>将线程转换成守护线程可以通过Thread对象的setDaemon(true)方法来实现。使用守护线程需要注意：</p>
<blockquote>
<ol>
<li>thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。 </li>
<li>在Daemon线程中产生的新线程也是Daemon的</li>
<li>守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断(如：非守护线程都停止了)。</li>
</ol>
</blockquote>
<h2 id="1-4-Thread类常用方法"><a href="#1-4-Thread类常用方法" class="headerlink" title="1.4 Thread类常用方法"></a>1.4 Thread类常用方法</h2><h3 id="1-4-1-start"><a href="#1-4-1-start" class="headerlink" title="1.4.1 start()"></a>1.4.1 start()</h3><p>start作用就是启动一个线程，他和run()的区别在前面也有说过</p>
<p>需要注意的是，如果多个线程在程序代码中顺序的调用start方法，并能保证两个线程的启动顺序，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread</span><br><span class="line">    t1 = <span class="keyword">new</span> Thread(),</span><br><span class="line">    t1 = <span class="keyword">new</span> Thread(),</span><br><span class="line">    t1 = <span class="keyword">new</span> Thread();</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br></pre></td></tr></table></figure></p>
<p>实际的启动顺序是随机，和cpu的调度有关</p>
<h3 id="1-4-2-sleep"><a href="#1-4-2-sleep" class="headerlink" title="1.4.2 sleep()"></a>1.4.2 sleep()</h3><p>sleep(long mills) 是Thread 类的一个今天native的方法，调用sleep线程进入阻塞。参数为0则一直等待。</p>
<p>需要注意的是，<strong>如果线程中获得某个对象的内置锁，在sleep的时候是不会释放锁的，这点和后面要说的wait()不同，wait()是会释放锁的</strong></p>
<blockquote>
<p>Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds, subject to the precision and accuracy of system timers and schedulers. The thread does not lose ownership of any monitors.</p>
</blockquote>
<p>以上引用自sleep方法源码上面的解释，最后一句说明了，sleep不释放锁</p>
<h3 id="1-4-3-interrupt"><a href="#1-4-3-interrupt" class="headerlink" title="1.4.3 interrupt()"></a>1.4.3 interrupt()</h3><p>调用线程打断，如果线程正因为调用了wait() ,sleep(),join等方法阻塞的时候，就会抛出一个InterruptedException</p>
<h3 id="1-4-4-wait、notify-notifyAll"><a href="#1-4-4-wait、notify-notifyAll" class="headerlink" title="1.4.4 wait、notify()/notifyAll()"></a>1.4.4 wait、notify()/notifyAll()</h3><p>这三个方法都是Object类实例的方法，<strong>由于这三个方法在使用的时候都涉及到锁的操作(获取和释放)，因此，这三个方法必须要在同步代码块中执行</strong>，否则抛出IllegalMonitorStateException异常。</p>
<p>使用示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread wait方法学习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v0.0.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017-03-21 14:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Integer o = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"thread one start..."</span>+System.currentTimeMillis());</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">3000</span>);<span class="comment">// 让t2先获得o的内置锁</span></span><br><span class="line">					<span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">						System.out.println(<span class="string">"notify thread two on object o before..."</span>+System.currentTimeMillis());</span><br><span class="line">						o.notify();</span><br><span class="line">						System.out.println(<span class="string">"notify thread two on object o end..."</span>+System.currentTimeMillis());</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(<span class="string">"thread one end..."</span>+System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">					System.out.println(<span class="string">"thread two start..."</span>+System.currentTimeMillis());</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						o.wait(<span class="number">0</span>);</span><br><span class="line">						System.out.println(<span class="string">"awake...."</span>+System.currentTimeMillis());</span><br><span class="line">						Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(<span class="string">"thread two end..."</span>+System.currentTimeMillis());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		t2.start();</span><br><span class="line">		t1.start();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">thread two start...1490176028853</span></span><br><span class="line"><span class="comment">thread one start...1490176028853</span></span><br><span class="line"><span class="comment">notify thread two on object o before...1490176031854</span></span><br><span class="line"><span class="comment">notify thread two on object o end...1490176031854</span></span><br><span class="line"><span class="comment">thread one end...1490176031854</span></span><br><span class="line"><span class="comment">awake....1490176031854</span></span><br><span class="line"><span class="comment">thread two end...1490176032854</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，t1 和 t2 都是对Object o 加锁，但是在t2里面o.wait之后，t1就能拿到锁了（awake…. 比 notify xxxx 后打印，t2的同步块没有执行完，锁就释放了），所以可以看出，wait是会释放锁的。</p>
<p>同时程序中为了使t2先拿到锁o从而先wait住，然后让t1 中释放锁o,故意在t1进来后先sleep了。那实际开发中肯定不能这样，实际应该怎样做呢 ？</p>
<p>在多线环境先一般建议在循环中使用wait,使用循环的条件做判断，例如在join的源码中有一段，如果join的是时间传的是0的情况的处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样在线程顺序未知的情况下，依然可以让wait生效</p>
<p>所有借鉴这个，实际生产中，我们控制好循环条件，就可以正确的使用wait了。</p>
<p>总的来说就是： <strong>wait方法会释放锁，当前的线程(上例中的t2)被挂起,且wait方法要在循环中使用，控制好条件来跳出循环</strong>，notify/notifyAll 配饰wait使用</p>
<p>结合上面的例子就是，t2中调用o.wait的时候，t2线程被挂起，不在执行，需要等待唤醒。o.wait() 释放掉t2对o的锁，使t1能够获得o的锁，执行o.notify唤醒t2,然后t2继续执行完成。</p>
<h3 id="1-4-5-yield"><a href="#1-4-5-yield" class="headerlink" title="1.4.5 yield()"></a>1.4.5 yield()</h3><p>简单讲就是告诉cpu我可以让出资源，注意是可以，也就是说，具体会不会让出，看cpu的调度了。此方法一般少用</p>
<h3 id="1-4-6-join"><a href="#1-4-6-join" class="headerlink" title="1.4.6 join()"></a>1.4.6 join()</h3><p>join方法的实质是wait, 理解join单词的字面意思，也许会更好理解join做的事情。join就是加入，如果线程A里面执行了线程b.join() 就是A线程进入等待，等b线程执行完。再接着执行。 换个角度就像是A在完成一件事的时候，把另外一件事B加进来，所以join就很形象。</p>
<p>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * join方法测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v0.0.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017-03-21 9:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">			</span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"First task started"</span>);</span><br><span class="line">				System.out.println(<span class="string">"Sleeping for 2 seconds"</span>);</span><br><span class="line">				<span class="keyword">try</span></span><br><span class="line">				&#123;</span><br><span class="line">					Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">				&#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(<span class="string">"First task completed"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">			</span>&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					t1.join();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(<span class="string">"Second task completed"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ouput</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">First task started</span></span><br><span class="line"><span class="comment">Sleeping for 2 seconds</span></span><br><span class="line"><span class="comment">First task completed</span></span><br><span class="line"><span class="comment">Second task completed</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>从结果可以很清楚的看到，t2是在等t1执行完在执行的，哪怕t1中有sleep</p>
<p><strong>关于join的执行过程，他本质上是执行wait,那又是在哪notify的呢 ？调用join的过程是怎样的呢 ？</strong></p>
<p>先看源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先这个方法是一个Thread的实例的方法，并且注意是个同步的方法（很好理解，前面说的wait方法会操作锁嘛）</p>
<p>就那示例程序分析吧，t1.join() 最后调用到了join(0) ，那么就会进入如下代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码，isAlive是谁在调用，wait(0) 是谁在调用？肯定是调用join的实例也就是t1，那么也就是说这段的逻辑就是如果t1还存活，就一直调用t1.wait() ,而整个代码(t1.join)是在t2里面调用的。</p>
<p>那么，整个意思就是 t2中调用t1.join实际就是判断如果t1.isAlive == true 就调用t1.wait() ，t2 需要获取一个t1内置锁。直到某个地方调用t1.notify 释放t1的内置锁，t2才继续执行。</p>
<p>以上就是join的过程，那么，t1内置锁什么时候释放的呢 ？谁通知的t2(即执行t1.notify)的呢？刚才源码分析没见哪里notify,示例运行t2确实执行了啊，没有一直等待锁啊？</p>
<p>这个之前也困扰我很久，后来在知乎上看到了答案 <a href="https://www.zhihu.com/question/44621343" target="_blank" rel="noopener">https://www.zhihu.com/question/44621343</a> 回答者cao解释了。</p>
<p>在线程退出的jvm源码中有如下一段：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">作者：cao</span><br><span class="line">链接：https:<span class="comment">//www.zhihu.com/question/44621343/answer/97640972</span></span><br><span class="line">来源：知乎</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个c++函数：</span></span><br><span class="line"><span class="keyword">void</span> JavaThread::<span class="built_in">exit</span>(<span class="keyword">bool</span> destroy_vm, ExitType exit_type) ；</span><br><span class="line"></span><br><span class="line"><span class="comment">//这家伙是啥，就是一个线程执行完毕之后，jvm会做的事，做清理啊收尾工作，</span></span><br><span class="line"><span class="comment">//里面有一个贼不起眼的一行代码，眼神不好还看不到的呢，就是这个：</span></span><br><span class="line"></span><br><span class="line">ensure_join(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//翻译成中文叫 确保_join(这个)；代码如下：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ensure_join</span><span class="params">(JavaThread* thread)</span> </span>&#123;</span><br><span class="line">  Handle threadObj(thread, thread-&gt;threadObj());</span><br><span class="line"></span><br><span class="line">  <span class="function">ObjectLocker <span class="title">lock</span><span class="params">(threadObj, thread)</span></span>;</span><br><span class="line"></span><br><span class="line">  thread-&gt;clear_pending_exception();</span><br><span class="line"></span><br><span class="line">  java_lang_Thread::set_thread_status(threadObj(), java_lang_Thread::TERMINATED);</span><br><span class="line"></span><br><span class="line">  java_lang_Thread::set_thread(threadObj(), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//同志们看到了没，别的不用看，就看这一句，妈了个淡淡，</span></span><br><span class="line"><span class="comment">//thread就是当前线程，是啥是啥？就是刚才说的b线程啊。</span></span><br><span class="line">  lock.notify_all(thread);</span><br><span class="line"></span><br><span class="line">  thread-&gt;clear_pending_exception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样整个过程就清晰了。t1执行完了之后，对t1内置锁执行了notifyAll(),所有t2被唤醒，执行完成。</p>
<h2 id="1-5-wait-notify-notifyAll-和-循环检测等待的区别"><a href="#1-5-wait-notify-notifyAll-和-循环检测等待的区别" class="headerlink" title="1.5 wait-notify/notifyAll 和 循环检测等待的区别"></a>1.5 wait-notify/notifyAll 和 循环检测等待的区别</h2><p>之前有说过，wait和notify可以类似个等待通知，其实不用wait-notify模式也是可以做的，例如现有如下场景：</p>
<p>A让B帮自己去买包烟回来，A等到B把烟买回交给自己的时候，A才给B钱</p>
<p><strong>wait-notify的模式</strong></p>
<p>A中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!isGetCigarette) &#123; <span class="comment">//没有得到烟</span></span><br><span class="line">    cigarette.wait(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">giveMoneyToB();</span><br></pre></td></tr></table></figure></p>
<p>B中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果自己买到烟,就通知A </span></span><br><span class="line">cigarette.notify()</span><br></pre></td></tr></table></figure></p>
<p><strong>不用wait-notify</strong></p>
<p>A中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!isGetCigarette) &#123; <span class="comment">//没有得到烟</span></span><br><span class="line">    <span class="comment">// doNothing</span></span><br><span class="line">&#125;</span><br><span class="line">giveMoneyToB();</span><br></pre></td></tr></table></figure></p>
<p>B中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 如果自己买到烟就设置标识为true</span></span><br><span class="line">isGetCigarette = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>两种都要求isGetCigarette是一个共享的变量。</p>
<p>那么这两种有什么区别呢 ？ 如果没有区别，是不是wait-notify岂不是没有存在意义 ？</p>
<p>原因就在于：处于wait()中的线程是中断的，被挂起的，不会抢占cpu的计算时间；而相反的，无线循环保证了线程的就绪态，会占用cpu时间。占用cpu即会减少其他线程的计算资源，导致性能下降</p>

        </div>

        <div class="post-footer">
            <div>
                
                    转载声明：
                        商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Snippet</a>
                            
                                
            </div>
            <div>
                
            </div>
        </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2018/01/15/thread-03/" class="pre-post btn btn-default"><i class="fa fa-angle-left fa-fw"></i>上一篇</a>
        
            
                <a href="/2018/01/10/thread-01/" class="next-post btn btn-default">下一篇<i class="fa fa-angle-right fa-fw"></i></a>
                
</div>


    <div id="comments">
        
    <div id="uyan_frame"></div>
    <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2154669"></script>
    
    </div>
    
        <script src="/js/toc.js?rev=@@hash"></script>
                                </main>
                                
    <aside class="col-md-3 sidebar">

        
            
    <div class="widget">    
        <h3 class="title">搜索</h3>
        <div id="search-form">
            <div id="result-mask" class="hide"></div>
            <div class="search-area">
                
                    <input id="search-key" type="search" autocomplete="off" placeholder="搜点什么呢?">
                    <button type="button" class="search-form-submit" id="search-local">站内搜索</button>
                
                
            </div>
            <div id="result-wrap" class="hide">
                <div id="search-result"></div>
            </div>
            <div class="hide">
                <template id="search-tpl">
                    <div class="item">
                        <a href="/{path}" title="{title}">
                            <div class="title">{title}</div>
                            <div class="content">{content}</div>
                        </a>
                    </div>
                </template>
            </div>
        </div>
    </div>

                
            
    <div class="widget">
        <h3 class="title">分类</h3>
        <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/工具/"><i class="fa" aria-hidden="true">工具</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link current" href="/categories/语言基础/"><i class="fa" aria-hidden="true">语言基础</i></a><span class="category-list-count">9</span></li></ul>
    </div>


                
            
    <div class="widget">
      <h3 class="title">归档</h3>
        <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/"><i class="fa" aria-hidden="true">一月 2018</i></a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/"><i class="fa" aria-hidden="true">四月 2017</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/"><i class="fa" aria-hidden="true">三月 2017</i></a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/"><i class="fa" aria-hidden="true">二月 2017</i></a><span class="archive-list-count">1</span></li></ul>
    </div>


                
            
  <div class="widget">
    <h3 class="title">标签云</h3>
    <div class="content tag-cloud">
        <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/static/" style="font-size: 10px;">static</a> <a href="/tags/内部类/" style="font-size: 10px;">内部类</a> <a href="/tags/多线程/" style="font-size: 20px;">多线程</a> <a href="/tags/并发包/" style="font-size: 10px;">并发包</a> <a href="/tags/序列化/" style="font-size: 10px;">序列化</a> <a href="/tags/线程池/" style="font-size: 10px;">线程池</a> <a href="/tags/集合类/" style="font-size: 10px;">集合类</a>
    </div>
  </div>


                
            
    <div class="widget">
      <h3 class="title">社交</h3> 
        <div class="content social">
            
	            <a href="//github.com/funye" rel="external nofollow" title="Github" target="_blank">
			    	<i class="git fa fa-git"></i>
			    </a>
            
	            <a href="mailto:fun913510024@163.com" rel="external nofollow" title="邮箱" target="_blank">
			    	<i class="envelope-o fa fa-envelope-o"></i>
			    </a>
            
	            <a href="/" rel="external nofollow" title="联系QQ" target="_blank">
			    	<i class="qq fa fa-qq"></i>
			    </a>
            
	            <a href="/" rel="external nofollow" title="微博" target="_blank">
			    	<i class="weibo fa fa-weibo"></i>
			    </a>
            
	            <a href="/" rel="external nofollow" title="QQ群" target="_blank">
			    	<i class="users fa fa-users"></i>
			    </a>
            
	            <a href="/atom.xml" rel="external nofollow" title="RSS" target="_blank">
			    	<i class="feed fa fa-feed"></i>
			    </a>
            
        </div>
    </div>


                
            
    <div class="widget">
        <h3 class="title">友链</h3>
        <div class="content friends-link">
        
            <a href="https://github.funye.io" class="fa" target="_blank">个人博客</a>
        
        </div>
    </div>


                
                    <div class='widget toc-widget'>
                        <h3 class='title'>文章目录</h3>
                        <div id='toc'>toc</div>
                    </div>
    </aside>
    
                            </div>
                        </div>
                    </section>
                    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="hide">
	<i class="fa fa-chevron-up"></i>
</a>




                        <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <span>Copyright &copy; 2018
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="https://github.com/funye/hexo-theme-snippet" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>


    <script src="/js/search.js?rev=@@hash"></script>
        

            <script src="/js/app.js?rev=@@hash"></script>
        </body>

        </html>