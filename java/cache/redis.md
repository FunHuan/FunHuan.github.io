# redis基础总结

`时间`：`{docsify-updated}` <br>

---

## redis的持久化

关于redis的安装和基本使用，参考博客：

[redis安装和基础入门](http://blog.csdn.net/fun913510024/article/details/46822943)

[Redis数据库的学习与实践—Redis的常用命令及高级应用](http://blog.csdn.net/fun913510024/article/details/47321993)


1. RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。
2. AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。

Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。

也可以关闭持久化功能，让数据只在服务器运行时存在。

### RDB 模式

#### 配置方式

RDB 复制模式也称作快照模式，在指定时间间隔中保存数据快照。
```
save <seconds> <changes>
```
在 seconds 时间间隔中发生changes次数的变化，就触发一次快照保存。可以配置多条规则。

除了在redis的配置文件中配置快照的规则外，还可以手动直接触发一次快照。直接调用`SAVE` 或者 `BGSAVE`命令。


#### 工作原理

当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作：

1. Redis 调用 fork() ，同时拥有父进程和子进程。
2. 子进程将数据集写入到一个临时 RDB 文件中。
3. 当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。

这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益


#### 优缺点

- 优点

  1. RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。
  2. RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心。
  3. RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。
  4. RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。

- 缺点

  1. rdb模式按照指定时间发生几次变化来持久化数据，这就有可能在数据没有发生持久化的时候就宕机，导致当前时间段内的数据丢失
  2. 每次rdb回fork子进程进行，当数据量比较大的时候fork很耗时间，CPU紧张的时候更容易出现卡顿。

### AOF(AppendOnly File) 模式

在服务器突然断电，死机，或者调用`kill -9` 命令杀死redis的时候，使用rdb的方式持久化是不够，这个时候最新的操作是没有被持久化。因此redis提供另外的一种持久化方式，append-only file 。

#### AOF 配置方式

要启动AOF的方式，需要在配置文件中设置
```
appendonly yes
```
配置时候，redis没产生一条指令都会被追加到AOF文件中，当服务器重启的时候，redis就从这个文件中重新执行指令来回复数据到内存中。

**aof重写**
通过上面不难发现，如果每次执行指令被保存，aof文件会越来远大。例如，一个increment 100次，就有100条指令，但是实际可以在回复数据的时候调用一句`set` 指令回复到最后的数据就可以了。所以redis也内置了重写机制。在不中断对客户端的服务器的情况下，在后台对aof文件重写。reids 2.2之前。需要是不是的调用`BGREWRIETAOF`指令，redis 2.4之后都是自动触发此指令。

**同步频率配置 (how durable)**

多久把数据同步(fsync)一次到文件的策略有三种：
1. fsync always 每次新的指令，每条指令都加到aof。此方法非常非常的慢，但是非常安全。
2. fsync everysec每个一秒钟同步一次。这种方法速度很快，最坏情况是损失1s内的数据
3. never no 不同步，而是交给操作系统去处理。非常快，但是不安全。

redis默认和推荐的方法是每秒同步方式。 

**配置方式**：
```
# appendfsync always
appendfsync everysec
# appendfsync no
```

**AOF文件损坏怎么处理**
当AOF文件损坏的时候，redis不能再从AOF中恢复数据，可按找下面的步骤处理：
1. 备份当前AOF文件
2. 使用redis-check-aof工具修复原AOF文件，执行命令 `redis-check-aof --fix`
3. 选择性的使用`diff -u`检测两个文件的不同
4. 用修改后的文件重启服务

#### AOF 工作原理（rewrite）

1. redis forks 一个子进程
2. 子进程开始把AOF写到一个临时文件
3. 父进程计算所有的新变化并放在一个内存缓冲区（同时他还把这些变化写进老的AOF文件，所以重写失败，也是安全的）
4. 最后。redis自动用新文件替换老文件。开始往新文件添加数据


#### AOF 优缺点

**AOF 优点**：
1. 数据安全性更高，从同步机制上看。always方式满，但每条指令都存储。
2. aof是一个追加文件，出现问题可以使用redis-check-aof工具修复
3. 文件过大的时候会使用重写方式，只要文件存在，数据有可以恢复
4. 文件内容以redis的协议存储，方便解读。能偶方便导出和解析。

**AOF 缺点**：
1. 数据量过大的时候，redis的aof体积会比rdb文件大
2. 根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）


## 数据容灾

需要经常对数据数据（rdb文件）进行备份

1. 使用corn job方式，定去备份rdb文件到某个文件夹
2. 备份时间打上时间标签，使用find找到很早期的备份删除
3. 定期把备份放到当前物理机之外的机器备份一份。


----

## redis主从（redis replication）

### redis主从配置方式

配饰redis主从备份操作很简单。在master中绑定服务器的ip，再在slave中设置slaveof即可

例如master:192.168.206.200 slave:192.168.206.201

配置如下：

```
#master配置
bind 192.168.206.200
port 6379

#############################
#slave 配置
slaveof 192.168.206.200 6379
slave-serve-stale-data yes #yes：设置master挂了之后slave仍然提供已经存在是数据。no：提示同步中
slave-read-only yes # 设置slave只读，2.6之后默认是只读
```

还有就是配置diskless ,但是此种方式在redis官方的说法上面是还在实验阶段。

master可选配置

```
min-slaves-to-write 3 # 配置至少有 3个slave连接正常的时候才同步数据
min-slaves-max-lag 10 # 最大延时少于 10s
```

slave可选配置
```
slave-announce-ip 5.5.5.5 
slave-announce-port 1234 
```
此配置的目的在于向master申明自己的ip和端口

>注意：当master节点挂了时候，我们从服务同步就会失败，一般使用sentinel做主从同步监控和切换

### redis 主从特性

1. redis的主从同步时异步进行的。redis 2.8开始，slave告知周期性（acknowledge ）同步流中处理的数据数量。
2. 一个master可以有多个slave
3. slave也可以连接到其他的salve，形成一个流状（cascading-like）结构
4. redis的复制是非阻塞的，也就是说master在给一个或者多个同步数据的时候仍然可以处理客户端的请求
5. redis的复制在slave上面也是非阻塞的，slave可以利用之前的老数据处理请求，同步完成跟新老数据
6. 复制可以用于可扩展性，以便为只读查询拥有多个从站（例如，可以将慢速O（N）操作卸载到从站），或简单地用于数据冗余
7. 主从备份可以避免master把所有数据都持久化，可以设置master不持久化，让多个slave中的一台做持久化。但是这中设置一定要小心，重启master会是空数据，这个时候如果slave同步了，数据就丢失了。所有重启时要利用slave持久化的数据重启。

### 工作原理

当建立一个从机器的时候，会尝试发从一条psync命令。主机会检测这是不是第一次链接。如果不是，主机就只会发送差异性数据。其他情况就是同步全部数据。
当全部同步出发的时候，主机启动后台保存功能产生rdb文件，同时开启缓冲区接受新的写入。当保存工作完成后，然后把rdb文件发送给从机器，接着把缓冲区的指令也发给从机器，实现同步。

下一节，总结下如何建立高可用（High Availability）的redis服务


{{comment}}
