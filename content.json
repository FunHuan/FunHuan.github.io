{"meta":{"title":"独一无二","subtitle":null,"description":null,"author":"独一无二","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Java线程、线程池、并发包(4)","slug":"thread-04","date":"2018-01-16T03:01:00.000Z","updated":"2018-01-16T03:06:11.947Z","comments":true,"path":"2018/01/16/thread-04/","link":"","permalink":"http://yoursite.com/2018/01/16/thread-04/","excerpt":"","text":"1 Future与Callable使用Runnable接口有很大的局限性，他不能够返回一个值或者一个受检查的异常。这种情况下，可以使用Callable接口，其中V就是返回的结果。 Future用来接收callable结束后返回的结果。ExecuteService 的submit方法都是返回一个Future,可以利用Future获取执行的结果，同时可以利用Future取消任务。任务生命周期 创建，提交，执行，结束。如果任务提交，但是没有执行，可以使用Future 取消。 使用线程池(ThreadPoolExecute)的时候，ExecuteService的submit方法实际上使用的是AbstractExecutorService的submit。查看源码可以看到提交任务后返回的是 FutureTask 示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.fun.concurrent;import java.util.concurrent.*;/** * callable示例 * * @author fun * @date 2017-04-01 10:59 */public class FutureCallableDemo &#123; public static void main(String[] args) &#123; FutureCallableDemo test = new FutureCallableDemo(); ExecutorService executorService = Executors.newFixedThreadPool(2); //do test// test.testCallableTask(executorService); test.testRunableTask(executorService); executorService.shutdown(); &#125; public void testCallableTask(ExecutorService executorService) &#123; Callable&lt;String&gt; task = new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; System.out.println(\"invoke method call, \" + System.currentTimeMillis()); Thread.sleep(3000); System.out.println(\"method call is going to return, \" + System.currentTimeMillis()); return \"SUCCESS\"; &#125; &#125;; Future&lt;String&gt; future = executorService.submit(task); System.out.println(\"main is going to get callable future result, \" + System.currentTimeMillis()); try &#123; System.out.println(\"callable result = \" + future.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; System.out.println(\"main got the future result, \" + System.currentTimeMillis()); &#125; public void testRunableTask(ExecutorService executorService) &#123; Runnable runTask = new Runnable() &#123; @Override public void run() &#123; System.out.println(\"invoke method run, \" + System.currentTimeMillis()); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"method run is going to end, \" + System.currentTimeMillis()); &#125; &#125;; Future&lt;Integer&gt; runFuture = executorService.submit(runTask,new Integer(100));// Future&lt;?&gt; runFuture = executorService.submit(runTask); // 这两种方式区别，打开注释观察 try &#123; System.out.println(\"main is going to get runnable future result, \" + System.currentTimeMillis()); System.out.println(\"runnable result = \" + runFuture.get()); System.out.println(\"main got the future result, \" + System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行会发现future.get() 方法是一个阻塞的方法，一直等到任务执行完成得到结果。 思考：看上面例子可以看到一个问题，runnable的任务和callable的任务都是可以返回Futrue的，那么他们有什么区别呢 ？ 观察不难发现，Callable 返回结果是在call方法执行完成后返回的，他返回什么结果可以是call里面的计算得到的，类型为V即可。他的结果是可变的，程序运行返回的是什么就是什么。 但是Runable的返回结果只是提前定义的一个结果，可预期正确执行后的一个结果。他的结果在任务提交的时候已经决定了具体的值。 2 原子类 atomic原子类是如何保证原子操作的？ 回答这个问题之前，先一起来看一个原子类的源码 1234567891011121314151617181920212223// AtomicInteger部分源码// AtomicInteegr 加法操作public final int getAndAdd(int delta) &#123; for (;;) &#123; int current = get(); int next = current + delta; if (compareAndSet(current, next)) return current; &#125;&#125;/** * Atomically sets the value to the given updated value * if the current value &#123;@code ==&#125; the expected value. * * @param expect the expected value * @param update the new value * @return true if successful. False return indicates that * the actual value was not equal to the expected value. */public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update);&#125; 这段代码很关键的一个地方就是compareAndSwap (CAS) ，每次操作（写）之前，先比较一下值，确认没有被改过，才写数据。在compareAndSet的注释上面也很清楚的可以看到，只有当cuurent value==expect value的时候，才把value更新成update value。整个执行的原则就是： 先检查后执行 而compareAndSwapXXX是一个native的方法，是虚拟机底层的实现。 测试示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.fun.concurrent;import java.util.concurrent.atomic.AtomicInteger;import java.util.concurrent.atomic.AtomicReference;/** * 原子类操作 * * @author fun * @date 2017-04-01 12:07 */public class AtomicClassDemo &#123; public static void main(String[] args) &#123; AtomicInteger aint = new AtomicInteger(100); boolean b = aint.compareAndSet(100,200); // 修改expect与当前值不同测试 if (b) &#123; System.out.println(aint.get()); &#125; System.out.println(aint.getAndAdd(100)); System.out.println(aint.get()); System.out.println(\"-------------------\"); AtomicClassDemo ref1 = new AtomicClassDemo(); AtomicClassDemo ref2 = new AtomicClassDemo(); System.out.println(\"ref1=\" + ref1); System.out.println(\"ref2=\" + ref2); AtomicReference&lt;AtomicClassDemo&gt; ref3 = new AtomicReference&lt;&gt;(ref1); System.out.println(\"ref3 before set=\" + ref3); boolean b2 = ref3.compareAndSet(ref2,ref1); // 修改expect为ref1测试 System.out.println(b2); System.out.println(\"ref3 after set =\" + ref3); &#125;&#125;/** output: 200 200 300 ------------------- ref1=com.fun.concurrent.AtomicClassDemo@74a14482 ref2=com.fun.concurrent.AtomicClassDemo@1540e19d ref3 before set=com.fun.concurrent.AtomicClassDemo@74a14482 false ref3 after set =com.fun.concurrent.AtomicClassDemo@74a14482 */ 3 lock与ReentrantLock此小节重点学习下ReentrantLock,区别于内置锁，ReentrantLock是一个显示锁。他那有那些特性呢？ 3.1 轮询锁和定时锁使用tryLock() 方法可以在不能获取到锁的情况下，使用定时或者轮询的方式获取所，执行时间内没有完成就释放锁，平滑的退出任务。而内置锁会阻塞在获取锁的地方，一旦操作不当就可能发生死锁，如果出现死锁了，唯一的解决办法就是重启程序。使用定时或者轮询锁可以有效的避免死锁的问题。 转账示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.fun.concurrent;import java.util.Random;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * Created by fun * @date 2017/4/12. */public class ReentrantLockDemo &#123; public static void main(String[] args) &#123; ReentrantLockDemo test = new ReentrantLockDemo(); Account fromAcct = test.newAccount(4000); Account toAcct = test.newAccount(1000); test.transferMoney(fromAcct,toAcct,1000L,20000,TimeUnit.NANOSECONDS); System.out.println(\"fromAccount balance=\" + fromAcct.getBalance() + \"\\ntoAccount balance=\" + toAcct.getBalance()); &#125; // 转账示例 public boolean transferMoney(Account fromAcct, Account toAcct, long amount, long timeout, TimeUnit unit) &#123; long stopTime = System.nanoTime() + unit.toNanos(timeout); // 超时时间 while (true) &#123; if (fromAcct.lock.tryLock()) &#123; try &#123; if (toAcct.lock.tryLock()) &#123; try &#123; boolean rs = false; if (fromAcct.debit(amount) )&#123; rs = toAcct.credit(amount); &#125; return rs; &#125; finally &#123; toAcct.lock.unlock(); &#125; &#125; &#125; finally &#123; fromAcct.lock.unlock(); &#125; &#125; if (System.nanoTime() &gt; stopTime) &#123; // 如果已经超时了，就直接返回，提前结束任务 return false; &#125; try &#123; long x = new Random().nextInt(50) + 10; Thread.sleep(timeout/x ); // 过一会儿再尝试下一次获取锁 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; protected class Account &#123; private Lock lock = new ReentrantLock(); private long balance; public boolean debit(long amount) &#123; if (balance &lt; amount) &#123; return false; &#125; balance = balance - amount; return true; &#125; public boolean credit(long amount) &#123; balance = balance + amount; return true; &#125; /*getter and setter*/ &#125; public Account newAccount(long balance) &#123; Account account = new Account(); if (balance &gt; 0) &#123; account.setBalance(balance); &#125; else &#123; account.setBalance(0); &#125; return account; &#125;&#125; 在几次获得锁的地方，都是trylock, 在多线程的情况下，如果没有获得锁的时候，线程并不会阻塞，而是之后往后面运行。进入判断是否超时的语句。如果超时就退出，可以避免等待加锁可能出现的死锁问题。 注意：但是使用显示锁人的时候，很容易在编写程序的时候忘记了释放锁，切记，在使用显示锁的时候一定要在try-finally 的finally里面对锁进行释放。 3.2 可中断的锁操作lockInterruptibly()方法,可中断的获取锁的方式，在获取锁的过程中可能被中断，方法本身是可以抛出InterruptException的1234// 此方法源码 public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1); &#125; 他的使用和不同lock和tryLock一样，只是需要在外面处理lockInterruptibly的InterruptException. 3.3 非块结构加锁对链表上的每个节点单独建立锁，使不同的线程可以独立的对链表的不同部分进行操作。所得很模糊，需要结合ConcurrentHashMap理解 3.4 公平性公平性是在竞争资源时候的一种策略，大部分情况都是使用公平原则来获取锁，例如：FIFO 队列。但是，有时候前面的操作比较耗时的时候，会拖慢整个处理速率，这个时候不公平原则可以提前获得锁。例如，线程A获得一个对象的锁，现线程B和C都在等待这个锁，当A释放锁的时候，如果B唤醒的时间比较的久，此时C先获得锁，使用了并释放了，B刚好唤醒，获得锁。这个过程B的时间没有耽误。同时C也处理了，增加了吞吐量。但是，我还要说但是。使用不公平性的时候同样会有问题，不公平的比较极端的情况就是找出一个线程一直拿不到锁，一直等待。所以使用时候需要权衡和控制。 ReentrantLock 可以设置不保证公平性。 4 CountDownLatch &amp; Semaphore4.1 CountDownLatchCountDownLatch 有什么作用呢 ？它就是一个同步助手，它能够让一个或者多个线程等到另外的线程完成一系列的操作之后再执行。 内部有一个倒数计数器，当倒数计数器减到0的时候释放锁。 先看示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.fun.concurrent;import java.util.concurrent.CountDownLatch;/** * CountDownLatch 使用和测试 * * @author fun * @date 2017-04-13 17:50 */public class CountDownLatchDemo &#123; public static void main(String[] args) &#123; CountDownLatchDemo test = new CountDownLatchDemo(); int N = 10; CountDownLatch startSignal = new CountDownLatch(1); CountDownLatch doneSignal = new CountDownLatch(N); for (int i = 0; i &lt; N; i++) &#123; new Thread(test.newWorker(startSignal,doneSignal)).start(); &#125; try &#123; System.out.println(\"do something else 1\"); startSignal.countDown(); System.out.println(\"do something else 2\"); doneSignal.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public Worker newWorker(CountDownLatch startSignal, CountDownLatch doneSignal)&#123; return new Worker(startSignal,doneSignal); &#125; class Worker implements Runnable &#123; private final CountDownLatch startSignal; private final CountDownLatch doneSignal; Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123; this.startSignal = startSignal; this.doneSignal = doneSignal; &#125; public void run() &#123; try &#123; startSignal.await(); doWork(); doneSignal.countDown(); &#125; catch (InterruptedException ex) &#123;&#125; // return; &#125; void doWork() &#123; try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"do something...\"); &#125; &#125;&#125; 此示例中，所有Runnable共享一个startSignal 和 一个 doneSignal。CountDownLatch的 await() 方法等待计数器变为0在唤醒。而在执行countDown() 方法的时候，每次countDown就会是计数器减一，知道减少为0才释放。 查看源码中countDown 的过程1234567891011121314151617181920212223242526// countDownpublic void countDown() &#123; sync.releaseShared(1);&#125;// sync.releaseSharedpublic final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125;// tryReleaseShared 在countDownLatch中的Sync中有重写父类的方法protected boolean tryReleaseShared(int releases) &#123; // Decrement count; signal when transition to zero for (;;) &#123; int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; &#125;&#125; 很显然，只有当count=0的时候才会释放锁。在回头看上面的示例程序，分析如下： startSignal.countDown(); Runnable任务线程创建并start了，但是出于wait状态，等待计数器变为0，次代码操作把计数器减一变为0，所有任务开始工作。 System.out.println(“do something else 2”);主线程忙其他事情 doneSignal.await();所有任务完成之前，主线程从此处开始阻塞(挂起等待)。doneSignal计数器不变为0，主线程一直挂起。完成一个任务，count-1,直到所有任务完成，count=0,主线程醒过来并完成后面的动作。 利用CountDownLacth 能做很多事，例如进项大数据的一个累加，可以分成多个线程处理，然后在主线程中合并(累加)多个任务的结果。增加处理速率（这个有点像MapReduce的思想）。 思考： 其实看了CountDownLatch 之后，发现和volatile+synchronized效果很像。完全可以控制一个volatile的count变量等于任务数，完成一个任务，count-1,主线程wait,等到count=0。 效果差不多。但是代码实现上就较CountDownLatch 复杂点。所有有类似这样的功能，应该优先想到CountDownLatch 4.2 Semaphore使用信号量的时候，一个线程想要获得一个item,必须要先从Semaphore那里获得许可(permit)，保证item是可用的。当线程完成任务的时候，在向pool归还item同时还需要向Semaphore归还许可，以便其他线程可以使用item。需要注意的是，当调用acquire的时候，不需要额外加锁限制，因为这样将会阻止item被归还到pool。 实际上Semaphore已经封装了同步锁来保证item的获取，并且pool对每个item有单独的维护。 当Semaphore被初始化成一个并且只有之多一个许可的时候，他就表现成了一个互斥锁。这个更像一个Binary Semaphore一样，因为他只有两个状态： 有一个可用许可，没有可用许可。当以这种方式使用的时候，semaphore 和其他Lock的实现不同，他能够允许锁被线程本身释放，而不是锁的所有者。 Semaphore 构造方法有个释放使用公平锁的方式。当使用不公平锁的时候，不保证获取许可的先后顺序。公平性在前文有说过，有时候可以提高吞吐量，避免一直等待。但是也同样也会出现一直获取不到锁也进去一直等待。 Semaphore可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池 实现分析： Semaphore 实现和CountDownLatch有几分相似： CountDownLatch里面有个count计数器，每次操作countDown 则count = count-1 ,当count==0 的时候才释放所 Semaphore 则是内部维护一个available的数量，每次减去获取permits的数量，得到剩余的数量，释放锁的时候available加上归还的permit的数量。获取的锁的过程就是对available减操作，release则是加回对available的操作。 Semaphore默认实现是不公平性的，就以不公平性的实现来看吗：1234567891011121314151617181920final int nonfairTryAcquireShared(int acquires) &#123; for (;;) &#123; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125;&#125;protected final boolean tryReleaseShared(int releases) &#123; for (;;) &#123; int current = getState(); int next = current + releases; if (next &lt; current) // overflow throw new Error(\"Maximum permit count exceeded\"); if (compareAndSetState(current, next)) return true; &#125;&#125; 选取源码中关键的两个方法吗，加锁和解锁。 获取permit： 先使用getState后去当前可用的permit的数量，剩余数量=当前数量-申请的数量，然后再执行CAS设置状态,并返回剩余可用数量。 释放锁：释放锁的过程时间就是归还permit可用数量的过程。当前可用数量+归还数量&lt;当前数量的是时候，或者已经溢出，归还数量为负数了，如果current + releases &gt;=cuurent,执行CAS 设置状态值。 5 ConcurrentHashMap使用分段锁(Lock striping)的方式，使锁的粒度更细来实现更大程度的共享，提高并发性和伸缩性。 锁分段(Lock striping)：在某些情况下，可以将锁分解技术进一步扩展为对一组独立对象上的锁进行分解。这种情况被称为锁分段。 例如： 在concurrentHashMap 中使用一个包含16个锁的数组，每个锁保护一个散列桶，其中第N个散列桶由第（N mod 16）个锁来写入。假设散列函数具有合理性，并且关键字分布均匀，那么这大约能都把对于锁的请求减少到原来1/16。正是这项技术使得ConcurrentHashMap能够支持多大16个并发的写入器。 锁分段劣势： 与采用单个锁来实现独占访问相比，要获取多个锁来实现独占访问将更加困难并且开销更高。例如：ConcurrentHashMap在扩容的时候，以及重新计算Hash并且重新散列分布时候，都需要获取所有锁，实现整个Map的独占访问。","categories":[{"name":"语言基础","slug":"语言基础","permalink":"http://yoursite.com/categories/语言基础/"}],"tags":[{"name":"并发包","slug":"并发包","permalink":"http://yoursite.com/tags/并发包/"}]},{"title":"Java线程、线程池、并发包(3)","slug":"thread-03","date":"2018-01-15T03:01:00.000Z","updated":"2018-01-16T03:05:47.026Z","comments":true,"path":"2018/01/15/thread-03/","link":"","permalink":"http://yoursite.com/2018/01/15/thread-03/","excerpt":"","text":"1.线程池(java.util.concurrent)为什么要有线程池 ？ 我们知道。使用线程来处理任务，可以达到一定程度的并行计算的效果，在一些比较耗时的操作时候不用一直等待，比如以下i/o操作。那么每次需要的时候就创建一个线程来处理这种任务就好了，为什么要引入线程池这个概念呢？ 主要存在三方面的原因： 线程生命周期的开销非常高。 创建线程是需要时间的，并且需要JVM和底层操作系统提供一些辅助的支持，无限创建线程，必定在创建线程的时候消耗很多资源。 资源消耗。 活跃的线程必定要占据一定的内存，线程越多，使用的内存越大。当可运行的线程多于可用的处理器数量的时候，线程就会闲置。大量的闲置线程就会占据大量内存，给垃圾回收带来很多的压力。而且这些线程在资源CPU竞争的时候也将产生更大的开销。 稳定性。 之前的JVM的OOM中有提到过，过多的线程还会可能出现OOM异常。因为线程数量受制于JVM的参数配置，Thread构造方法中的请求栈大小，以及底层操作系统对线程的闲置，一旦超出就会出现OOM的异常 所以，使用线程池，用它来管理线程，可以有效的减少因为线程创建和线程数量过多导致的问题 1.1 Executor框架1.1.1 框架基础先来看看住基本的框架结构图： 1. 主要元素： 顶层是一个Executor接口，主要常用的实现类是ThreadPoolExecutor和ScheduledThreadPoolExecutor BlockingQueue接口及其实现 Future接口以及实现 Executors 创建线程池的关键类 2. 框架执行原理 关于执行原理，说到这个问题，不得不说jdk源码的作者写代码真是习惯好，跟进源码，查看Executor接口，在类上面，很大段的解释和说明，还有示例代码来说明。相比周围的我们写的代码，简简单单的几行注释，甚至有的完全写出来就是没有注释，试问这样代码怎么看。很多时候我觉得写代码好不好，代码风格和格式很重要。 回答我们刚才的话题，一起来看看Executor接口上面的注释吧 2.1 Excutor接口 我们去看源码就发现，Executor接口只有个方核心方法execute,接收的参数是Runnable。Runnable在jdk里面，我们都称之为Task也就是要执行的任务，使用Executor可是避免我们反复的使用new Thread(new(RunnableTask())).start()。当有很多任务需要执行的时候，可以如下的方式：12345// 异步执行任务 Executor executor = anExecutor; // 此处伪代码，实现时候就是使用Executors创建一个子类 executor.execute(new RunnableTask1()); executor.execute(new RunnableTask2()); ... 上面的代码，会使得多个任务异步的执行。在executor源码注释上有写明，这个接口也可以不要求任务是异步执行的，一个简单例子就是直接执行提交的任务的run方法123456// 直接同步执行class DirectExecutor implements Executor &#123; public void execute(Runnable r) &#123; r.run(); &#125;&#125; 但是更典型的方式使用一个线程来执行任务而不是使用run方法，例如：123456// 每个任务一个线程异步去执行class ThreadPerTaskExecutor implements Executor &#123; public void execute(Runnable r) &#123; new Thread(r).start(); &#125;&#125; 而在Executor框架中，Executor的实现类都是解决的批量任务的执行顺序和时间的问题。下面的例子是一个顺序执行的Executor的一个实现。12345678910111213141516171819202122232425262728293031// 多任务顺序执行class SerialExecutor implements Executor &#123; final Queue&lt;Runnable&gt; tasks = new ArrayDeque&lt;Runnable&gt;(); final Executor executor; Runnable active; SerialExecutor(Executor executor) &#123; this.executor = executor; &#125; public synchronized void execute(final Runnable r) &#123; tasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (active == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((active = tasks.poll()) != null) &#123; executor.execute(active); &#125; &#125;&#125; 上面这个例子基本能简单表现出执行任务的思路，值得注意的一点就是，这个jdk注释中的例子在executor中引入了一个任务队列，再把队列中的任务取出顺序执行。在JDK提供的Executor的实现类中，使用workQueue来存储需要执行的任务，使用一个Worker集合works来执行任务（不同于上例中的顺序执行，且上例中工作线程相当于只有一个）。执行Worker启动后执行完自己的runnable后还会从workQueue中继续获取任务执行，直到任务队列为空。 2.2 ExecutorService 接口 ExecutorService接口继承自Executor 接口，主要增加了线程生命周几管理的几个方法以及Future 来跟踪任务一个或多个异步任务的处理情况。 其中 shutDown() 关闭executor，已经提交的任务会被执行，新的任务不会再接受 shutDownNow() 立即关闭executor,停止执行，并返回一个等待执行的任务列表 isShutDown() executor是否终止 isTerminated() 所有任务执行完成，只有在调用了shutDown或者shutDownNow之后，才会返回true submit() 几种提交任务的方式 2.3 Executors 提供各种方法创建线程池，从大的方向看，线程主要分为两类，一种就是不同的异步执行的，一种就是实现了ScheduledExecutorService 接口的线程，两类线程的区别在于在于ScheduledExecutorService是那种有计划执行的任务，比如说定时任务或者延时执行的任务。 具体使用查看Executors.newXXX() 相关文档 1.1.2. ThreadPoolExecutor &amp; ScheduledThreadPoolExecutorThreadPoolExecutor 和 ScheduledThreadPoolExecutor 都是executorService的实现类，他们关系从之前类图已经可以清楚地看出来。基本使用差不多，却别就在于定位或者延时功能。所以本文只分析ThreadPoolExecutor的源码，来看看线程池的工作大致流程。 1.1.2.1 ThreadPoolExecutor源码分析在分析源码前，我根据个人的理解，先简单说明线程池工作的流程，在进入代码查看。 之前在看JDK的Executor接口的文档的时候，在源码上面的标准注释里面的例子（也是生成的javadoc里面的注释）的最后一个，有提到过一个概念，任务队列。前文还简单说了下具体实现类和那个例子的不同。现在来具体看看，在说之前，先明白几个概念。 工作队列 BlockingQueue&lt;Runnable&gt; workQueue。存放所有的runnable任务。 工作线程集合 HashSet&lt;Worker&gt; workers。线程池中所有的工作线程集合 Runnable都清楚是什么，Woker呢，先看看worker类可能更能方便理解线程池的工作过程 123456789101112131415161718192021222324252627282930313233// Wokerprivate final class Worker extends AbstractQueuedSynchronizer implements Runnable &#123; /** * This class will never be serialized, but we provide a * serialVersionUID to suppress a javac warning. */ private static final long serialVersionUID = 6138294804551838833L; /** Thread this worker is running in. Null if factory fails. */ final Thread thread; /** Initial task to run. Possibly null. */ Runnable firstTask; /** Per-thread task counter */ volatile long completedTasks; /** * Creates with given first task and thread from ThreadFactory. * @param firstTask the first task (null if none) */ Worker(Runnable firstTask) &#123; setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); &#125; /** Delegates main run loop to outer runWorker */ public void run() &#123; runWorker(this); &#125;..... 很明显就是有个线程，一个任务，和任务完成数量，核心方法是runWorker 1234567891011121314151617181920212223242526272829303132333435363738394041424344// runWorkerfinal void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; while (task != null || (task = getTask()) != null) &#123; w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; beforeExecute(wt, task); Throwable thrown = null; try &#123; task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125; &#125; runWorker做的事情很明确，如果Worker创建的时候带了任务，则执行这个任务的run()方法，如果没有就去执行getTask()在workQueue中获得一个任务来执行，直到没任务可执行为止。 在回头看execute方法：123456789101112131415161718192021222324252627282930313233343536373839public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); /* * Proceed in 3 steps: * * 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn't, by returning false. * * 2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none. * * 3. If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task. */ int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; else if (!addWorker(command, false)) reject(command); &#125; 这段执行逻辑： 查看当前Worker(工作线程)数量有没有达到coreSize,没有就创建一个工作线程 如果线程池没有关闭，并且添加到队列成功，再次执行下检测，或者拒绝，或者由于工作线程没有重新添加工作线程。这个分支需要注意的是，可能这个分支走完只添加了任务，没有添加线程。也就是重复利用线程。利用已有的工作线程自己去队列中消费任务。例外注意runWorker里面使用的getTask() 实际是个阻塞的，一直循环在取队列中的任务，取不到一直循环，这个线程就会一直在。runWorker也是个死循环一直执行task.run。所以线程中的线程其实一直在运行的。但是getActiveCount 是去HashSet workers 里面的上锁(在执行run的线程，而不是在getTask的)的线程数量。 添加任务失败的时候，直接拒绝 这里另外说一下，。 12345678910// addWorker 部分代码...w = new Worker(firstTask); final Thread t = w.thread;... if (workerAdded) &#123; t.start(); workerStarted = true; &#125;... addWorker最后会启动worker的私有属性thread的线程，开始执行runWorker,同事把worker添加到HashSet中由于worker的构造函数中this.thread = getThreadFactory().newThread(this); 所以woker的thread启动的时候，执行的就是Wroker的run，即threadPoolExecutor的runWorker方法。整个执行链如下： ThreadPoolExecutor.execute()--&gt;addWorkder(可能添加成功或者失败，失败是涉及到拒绝处理问题)--&gt;Workder.thread.start()--&gt;Worker.run--&gt;threadPoolExecutor.runWorker--&gt;循环执行getTask、task.run 以上就是线程基本的执行流程了，观察ThreadPoolExecutor的完整参数的构造方法发现：1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; 其中ThreadFactory 是用来创建Worker的thread用的，管理所有的线程。RejectedExecutionHandler handler是在addWorker的时候如果添加失败，执行的饱和策略。JUC(java.util.concurrent)包中有提供几种实现。也可以根据需要自己实现自己的饱和策略。 1.1.2.2 Exexutors.newXXX的参数意义和是使用时候注意的问题 newFixedThreadPool创建一个固定长度的线程池，每次提交任务就会创建线程，知道达到最大线程数。如果线程发生Exception死掉，会新补充线程进来。默认工作队列最大长度是Integer.MXA_VALUE。认为是一个无界的队列 newCachedThreadPool创建一个可缓存的线程池，如果线程池的当前规模超出了处理需求，就回收空闲线程，如果需求增加就添加新的线程。线程值规模不受限制，所以在使用的时候，操作不当可能创建很多线程导致OOM。使用的队列是SynchronousQueue. newScheduledThreadPool创建固定长度线程池，而且以延迟或定时的方式来执行任务 newSingleThreadExecutor、newSingleThreadScheduledExecutor创建一个单线程的Executor，如果单个线程出现Exeception死掉，就是创建一个线程来替代。他可以确保任务队列中的任务是顺序执行的。 1.2. 线程池任务管理 Queue &amp; DequeThreadPoolExecutor提供了三中队列方式：无界队列、有界对列、同步移交。队列的选择与其他的参数有关，例如：线程池的大小。 无界、有界队列。使用无界队列当线程池中的线程都处于忙碌状态的时候，工作队列就会无限制的增长。一种更加稳妥的方式使用有界队列，例如：ArrayBlockingQueue，有界LinkedBlockingQueue，PriorityBlockingQueue。有界队列有助于避免资源耗尽情况的发生，但是就需要考虑队列填满时候的饱和策略问题。 同步移交。对于非常大或者无界的线程池，可以使用SynchronousQueue来避免任务排队，以及直接将任务从生产者直接移交给工作线程，移交的时候必须要求有线程等待接受，如果没有切线程池线程数小于最大线程，就创建线程接受，否则就拒绝。 执行顺序 。ArrayBlockingQueue 和 PriorityBlockingQueue是FIFO类型队列，如果想进一步的控制任务执行的顺序，可以使用PriorityBlockingQueue来进行管理，任务优先级是通过自然顺序或者Comparator接口来定义的。 注意：只有当任务相互独立是，为线程池或者工作队列设置界限才是合理的，如果任务之间存在依赖，那么有界的线程池或者队列就可能导致“饥饿”死锁问题 1.3 线程池饱和策略 RejectedExecutionHandler当有界队列被填满的时候，饱和策略就开始发挥作用了。ThreadPoolExecutor的饱和策略可以通过调用setRejectedExecutionHandler来修改。JDK提供了四种默认的饱和策略。 AbortPolicy 默认策略，抛出一个未经检测的RejectedExecutionException,调用者捕获这个异常，根据自己的需求编写自己的代码。 DiscardPolicy 抛弃策略， 当新的任务无法添加到队列的时候，默默的抛弃该任务 DiscardOldestPolicy 抛弃最早策略，次策略会抛弃写一个要执行的任务，然后尝试提交任务123456 public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; e.getQueue().poll(); e.execute(r); &#125;&#125; 因此如果是个优先队列，则抛弃优先级最高的策略，所有不建议这个策略和优先队列一起使用 CallerRunsPolicy 调用者直接执行run策略，这种直接在调用者的线程执行任务的run方法。12345public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; r.run(); &#125;&#125; 因为直接下调用者里面执行的任务，所有会是一个同步的效果，就会带来响应的延时。 以上四种是JDK提供的策略，我们还可以根据自己的需要，自己实现RejectedExecutionHandler，实现我们自己的饱和策略。 1.4 线程池如何重复利用线程的 ？1.4.1 ThreadFactory线程工厂是创建线程的地方，实际就是创建工作线程。 1234567891011// DefaultthreadFactorypublic Thread newThread(Runnable r) &#123; Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); if (t.isDaemon()) t.setDaemon(false); if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t;&#125; 1.4.2 线程池如何重复利用线程？通过前面对线程池的理解，线程池的实现思路基本有一定的了解，那么线程池究竟如何重复利用线程的呢？ 其实这里的“重复” 并没有放开重新获取，而是工作线程一直运行。当运行的线程数量没有达到coreSize的时候，不管任务多少，新来任务会重新创建工作线程。工作线程中执行的是死循环一直获取任务来执行。通过使用工作线程来执行任务的run方法达到避免创建线程的目的。前面源码分析部分，查看execute、addWorker、runWorker、getTask 四个方法就很明了。 execute: 添加工作线程，或者只添加任务、或者拒绝任务 addWorker: 实际上的创建工作线程，并start runWorker: 工作线程的run方法里面执行的代码，循环取队列的中的任务进行执行。 getTask: 一直去任务，队列为空就一直循环直到取到值或者线程池关闭。 所以线程池的工作线程一点启动，是一直在运行的。没有任务可执行的时候，也是在执行，只不过这个时候是阻塞在了getTask方法中。所以千万不要理解成线程池做完任务就把线程放回去，要用的时候在拿出来。","categories":[{"name":"语言基础","slug":"语言基础","permalink":"http://yoursite.com/categories/语言基础/"}],"tags":[{"name":"线程池","slug":"线程池","permalink":"http://yoursite.com/tags/线程池/"}]},{"title":"Java线程、线程池、并发包(2)","slug":"thread-02","date":"2018-01-14T03:01:00.000Z","updated":"2018-01-16T03:02:10.780Z","comments":true,"path":"2018/01/14/thread-02/","link":"","permalink":"http://yoursite.com/2018/01/14/thread-02/","excerpt":"","text":"java的线程Thread 现在的操作系统是多任务操作系统。多线程是实现多任务的一种方式。 进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程中可以启动多个线程。比如在Windows系统中，一个运行的exe就是一个进程。 线程是指进程中的一个执行流程，一个进程中可以运行多个线程。比如java.exe进程中可以运行很多线程。线程总是属于某个进程，进程中的多个线程共享进程的内存。 引用网上对线程的一个说法，个人觉得比较的形象 1.1 线程的创建和启动1.1.1 线程创建创建线程方式主要有两个： 继承Thread类，利用构造方法创建一个线程 实现Runnable接口。在利用带Runnable参数的构造方法 看例子： 1. 实现Thread类 1234567891011121314class PrimeThread extends Thread &#123; long minPrime; PrimeThread(long minPrime) &#123; this.minPrime = minPrime; &#125; public void run() &#123; // compute primes larger than minPrime . . . &#125; &#125; PrimeThread p = new PrimeThread(143);p.start(); 2. 实现Runnable 接口 1234567891011121314 class PrimeRun implements Runnable &#123; long minPrime; PrimeRun(long minPrime) &#123; this.minPrime = minPrime; &#125; public void run() &#123; // compute primes larger than minPrime . . . &#125; &#125;PrimeRun p = new PrimeRun(143); new Thread(p).start(); 1.1.2 Thread和Runnable看了上面分别使用继承的方式和runnable接口的方式，那他们又有何不同呢 其实看看两者的代码区别就知道了，如果继承的话，每次new Thread创建一个新的线程，然而runnable的方式虽然也是每次new Thread() ，但是，构造方法中的runnable可以是同一个也可以是每次new一个。这点可以有很大的区别，可以很好利用 假如我们线程有个自己的私有成员，对应使用继承Thread 的方式，每次new ,这个私有成员一定是自己所有的。但是使用runnable的话，就不一定了。 12345678910111213141516171819202122232425262728293031323334package com.fun.thread;/** * 实现runnable接口的任务类 * * @author fun * @version v1.0.0 * @create 2017-03-13 21:46 */public class TestTask implements Runnable &#123; private int taskId; volatile private int count; // 可以做共享变量 public TestTask(int taskId,int count) &#123; this.taskId = taskId; this.count = count; &#125; @Override public void run() &#123; System.out.println(\"taskId is:\"+taskId+\" , count is:\"+count); try &#123; System.out.println(\"threadId: \"+Thread.currentThread().getId()+ \", threadName: \"+Thread.currentThread().getName()+ \",isDaemon \" + Thread.currentThread().isDaemon()); Thread.sleep(200); count--; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 上面这段代码是一个实现runnable接口的任务。请看在使用时候的区别 1234567891011121314151617@Test public void test1() throws InterruptedException &#123; // 1. 每个线程都有一个新的Runnable for (int i = 0; i &lt; 10; i++) &#123; new Thread(new TestTask(i + 1, 10)).start(); Thread.sleep(200); &#125; &#125; @Test public void test2() throws InterruptedException &#123; TestTask testTask = new TestTask(1, 10); for (int i = 0; i &lt; 10; i++) &#123; new Thread(testTask).start(); Thread.sleep(200); &#125; &#125; 上面结果 test1中，每次new TestTask传递给Thread,所以打印的都是count=10 test2中，每个Thread其实都是用的一个runnable构造，这个时候他们共享TestTask的count值。打印的count减小了 所以这里可以利用这个特点处理共享资源，只要合理加锁，就可以处理好共享资源，如上面count加上volatile 保证可见性，再count– 加块级锁就ok 1.1.3 线程启动之前也有代码使用过线程，线程启动一般使用 start() 或者 run() 但是一般建议是start() 为什么建议使用start() ? 其实使用run()和start()，最终都是调用的run,最重要的区别在于，执行方法的线程是谁。使用 start() 方法，是新建立的线程在执行，然而使用run()时候，是run()调用处的线程（如果在主线程直接调用了run() ,操作run()的线程就是main,并不是生成的新的线程） 12345678910111213141516171819@Testpublic void testRunAndStartDiff() &#123; System.out.println(\"main threadId: \"+Thread.currentThread().getId()+ \",main threadName: \"+Thread.currentThread().getName()+ \",isDaemon \" + Thread.currentThread().isDaemon()); Thread t = new Thread(new TestTask(1,10)); t.start(); Thread t2 = new Thread(new TestTask(2,20)); t2.run();&#125;main threadId: 1,main threadName: main,isDaemon falsetaskId is:2 , count is:20threadId: 1, threadName: main,isDaemon falsetaskId is:1 , count is:10threadId: 11, threadName: Thread-0,isDaemon false 可以看到 Task 2 是用的run() ,实际上是ThreadId=1 的线程执行的（main）Task1 是自己生成的线程（ThreadId=11）执行的 所以，注意是谁执行自己，在多线程处理的时候，取Thread.currentThread()注意，是start()启动还是run启动 生活一个开关我们打开了，自己有可能把它关掉在打开。同样，如果一个线程start()之后，我还可以拿着这个Thread 在开始一次吗 例如：123456789@Testpublic void testMultiCallStart() &#123; Thread t = new Thread(new TestTask(1,10)); t.start(); t.start(); &#125;测试结构是不能再次调用start，直接报java.lang.IllegalThreadStateException 跟进start() 方法源码就会发现12if (threadStatus != 0) throw new IllegalThreadStateException(); start()之前会先判断线程状态,但是如果用 t.run() 是可以多次调用的。也算是start() 和 run()的区别吧 ，因为直接调用run()其实都没有新建线程 说到线程状态，那么来看看线程的状态到底有哪些？ 1.2 线程状态1.2.1 线程状态分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public enum State &#123; /** * Thread state for a thread which has not yet started. */ NEW, /** * Thread state for a runnable thread. A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. */ RUNNABLE, /** * Thread state for a thread blocked waiting for a monitor lock. * A thread in the blocked state is waiting for a monitor lock * to enter a synchronized block/method or * reenter a synchronized block/method after calling * &#123;@link Object#wait() Object.wait&#125;. */ BLOCKED, /** * Thread state for a waiting thread. * A thread is in the waiting state due to calling one of the * following methods: * &lt;ul&gt; * &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;/li&gt; * &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;/li&gt; * &lt;/ul&gt; * * &lt;p&gt;A thread in the waiting state is waiting for another thread to * perform a particular action. * * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt; * on an object is waiting for another thread to call * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt; * is waiting for a specified thread to terminate. */ WAITING, /** * Thread state for a waiting thread with a specified waiting time. * A thread is in the timed waiting state due to calling one of * the following methods with a specified positive waiting time: * &lt;ul&gt; * &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt; * &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt; * &lt;/ul&gt; */ TIMED_WAITING, /** * Thread state for a terminated thread. * The thread has completed execution. */ TERMINATED; &#125; NEW 创建完成，但是没有启动 RUNABLE 运行状态。正在java虚拟中被执行，但是有可能正在等待系统资源，比如处理器资源 BLOCKED 受阻塞，并在等待监视器锁。线程正在等待监视器锁，以便进入同步方法/块，或者这调用Object.wait()方法后再次进入同步方法/块 WAITING 等待中，线程调用如下方法会进入等待状态 Object.wait()并且没有超时时间 Thread.join() 并且没有超时时间 LockSupport.park() 例如：已经在某一对象上调用了 Object.wait() 的线程正等待另一个线程，以便在该对象上调用 Object.notify() 或 Object.notifyAll()。 TIMED_WAITING 指定等待时间的等待，调用如下方法会进入此状态 Thread.sleep() Object.wait() 指定超时时间 Thread.join() 执行超时时间 LockSupport.parkNanos LockSupport.parkUntil TERMINATED 线程结束，完成执行 1.2.2 线程状态转换图线程状态之间的转换图 1.3 关于守护线程 Daemon Threadjava中的线程分为两类：用户线程(User Thread)、守护线程(Daemon Thread) 守护线程就是程序运行的时候在后台提供一种通用的服务的线程。比如：垃圾回收线程。这种线程并不是程序中不可或缺的，因此，当所有的非守护线程结束时候，程序也会终止，同时会杀死进程中所有的守护线程。 用户线程和守护线程几乎没有什么区别，唯一的不同之处在于虚拟机的离开：如果所有的用户线程结束了，守护线程没有守护对象，程序还是会结束。 将线程转换成守护线程可以通过Thread对象的setDaemon(true)方法来实现。使用守护线程需要注意： thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。 在Daemon线程中产生的新线程也是Daemon的 守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断(如：非守护线程都停止了)。 1.4 Thread类常用方法1.4.1 start()start作用就是启动一个线程，他和run()的区别在前面也有说过 需要注意的是，如果多个线程在程序代码中顺序的调用start方法，并能保证两个线程的启动顺序，例如：12345678Thread t1 = new Thread(), t1 = new Thread(), t1 = new Thread();t1.start();t2.start();t3.start(); 实际的启动顺序是随机，和cpu的调度有关 1.4.2 sleep()sleep(long mills) 是Thread 类的一个今天native的方法，调用sleep线程进入阻塞。参数为0则一直等待。 需要注意的是，如果线程中获得某个对象的内置锁，在sleep的时候是不会释放锁的，这点和后面要说的wait()不同，wait()是会释放锁的 Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds, subject to the precision and accuracy of system timers and schedulers. The thread does not lose ownership of any monitors. 以上引用自sleep方法源码上面的解释，最后一句说明了，sleep不释放锁 1.4.3 interrupt()调用线程打断，如果线程正因为调用了wait() ,sleep(),join等方法阻塞的时候，就会抛出一个InterruptedException 1.4.4 wait、notify()/notifyAll()这三个方法都是Object类实例的方法，由于这三个方法在使用的时候都涉及到锁的操作(获取和释放)，因此，这三个方法必须要在同步代码块中执行，否则抛出IllegalMonitorStateException异常。 使用示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Thread wait方法学习 * * @author fun * @version v0.0.1 * @date 2017-03-21 14:45 */public class WaitTest &#123; private static volatile Integer o = 0; public static void main(String[] args) &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"thread one start...\"+System.currentTimeMillis()); try &#123; Thread.sleep(3000);// 让t2先获得o的内置锁 synchronized (o) &#123; System.out.println(\"notify thread two on object o before...\"+System.currentTimeMillis()); o.notify(); System.out.println(\"notify thread two on object o end...\"+System.currentTimeMillis()); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"thread one end...\"+System.currentTimeMillis()); &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (o) &#123; System.out.println(\"thread two start...\"+System.currentTimeMillis()); try &#123; o.wait(0); System.out.println(\"awake....\"+System.currentTimeMillis()); Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"thread two end...\"+System.currentTimeMillis()); &#125; &#125; &#125;); t2.start(); t1.start(); &#125;&#125;// output/*thread two start...1490176028853thread one start...1490176028853notify thread two on object o before...1490176031854notify thread two on object o end...1490176031854thread one end...1490176031854awake....1490176031854thread two end...1490176032854*/ 可以看到，t1 和 t2 都是对Object o 加锁，但是在t2里面o.wait之后，t1就能拿到锁了（awake…. 比 notify xxxx 后打印，t2的同步块没有执行完，锁就释放了），所以可以看出，wait是会释放锁的。 同时程序中为了使t2先拿到锁o从而先wait住，然后让t1 中释放锁o,故意在t1进来后先sleep了。那实际开发中肯定不能这样，实际应该怎样做呢 ？ 在多线环境先一般建议在循环中使用wait,使用循环的条件做判断，例如在join的源码中有一段，如果join的是时间传的是0的情况的处理：12345if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; 这样在线程顺序未知的情况下，依然可以让wait生效 所有借鉴这个，实际生产中，我们控制好循环条件，就可以正确的使用wait了。 总的来说就是： wait方法会释放锁，当前的线程(上例中的t2)被挂起,且wait方法要在循环中使用，控制好条件来跳出循环，notify/notifyAll 配饰wait使用 结合上面的例子就是，t2中调用o.wait的时候，t2线程被挂起，不在执行，需要等待唤醒。o.wait() 释放掉t2对o的锁，使t1能够获得o的锁，执行o.notify唤醒t2,然后t2继续执行完成。 1.4.5 yield()简单讲就是告诉cpu我可以让出资源，注意是可以，也就是说，具体会不会让出，看cpu的调度了。此方法一般少用 1.4.6 join()join方法的实质是wait, 理解join单词的字面意思，也许会更好理解join做的事情。join就是加入，如果线程A里面执行了线程b.join() 就是A线程进入等待，等b线程执行完。再接着执行。 换个角度就像是A在完成一件事的时候，把另外一件事B加进来，所以join就很形象。 示例代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * join方法测试 * * @author fun * @version v0.0.1 * @date 2017-03-21 9:37 */public class JoinTest &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(new Runnable() &#123; public void run() &#123; System.out.println(\"First task started\"); System.out.println(\"Sleeping for 2 seconds\"); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"First task completed\"); &#125; &#125;); Thread t2 = new Thread(new Runnable()&#123; public void run() &#123; try &#123; t1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"Second task completed\"); &#125; &#125;); t1.start(); t2.start(); &#125;&#125;// ouput/*First task startedSleeping for 2 secondsFirst task completedSecond task completed*/ 从结果可以很清楚的看到，t2是在等t1执行完在执行的，哪怕t1中有sleep 关于join的执行过程，他本质上是执行wait,那又是在哪notify的呢 ？调用join的过程是怎样的呢 ？ 先看源码：12345678910111213141516171819202122232425262728public final synchronized void join(long millis)throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException(\"timeout value is negative\"); &#125; if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; else &#123; while (isAlive()) &#123; long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125;&#125;public final void join() throws InterruptedException &#123; join(0);&#125; 首先这个方法是一个Thread的实例的方法，并且注意是个同步的方法（很好理解，前面说的wait方法会操作锁嘛） 就那示例程序分析吧，t1.join() 最后调用到了join(0) ，那么就会进入如下代码块 12345if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125;&#125; 这段代码，isAlive是谁在调用，wait(0) 是谁在调用？肯定是调用join的实例也就是t1，那么也就是说这段的逻辑就是如果t1还存活，就一直调用t1.wait() ,而整个代码(t1.join)是在t2里面调用的。 那么，整个意思就是 t2中调用t1.join实际就是判断如果t1.isAlive == true 就调用t1.wait() ，t2 需要获取一个t1内置锁。直到某个地方调用t1.notify 释放t1的内置锁，t2才继续执行。 以上就是join的过程，那么，t1内置锁什么时候释放的呢 ？谁通知的t2(即执行t1.notify)的呢？刚才源码分析没见哪里notify,示例运行t2确实执行了啊，没有一直等待锁啊？ 这个之前也困扰我很久，后来在知乎上看到了答案 https://www.zhihu.com/question/44621343 回答者cao解释了。 在线程退出的jvm源码中有如下一段：1234567891011121314151617181920212223242526272829303132作者：cao链接：https://www.zhihu.com/question/44621343/answer/97640972来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。//一个c++函数：void JavaThread::exit(bool destroy_vm, ExitType exit_type) ；//这家伙是啥，就是一个线程执行完毕之后，jvm会做的事，做清理啊收尾工作，//里面有一个贼不起眼的一行代码，眼神不好还看不到的呢，就是这个：ensure_join(this);//翻译成中文叫 确保_join(这个)；代码如下：static void ensure_join(JavaThread* thread) &#123; Handle threadObj(thread, thread-&gt;threadObj()); ObjectLocker lock(threadObj, thread); thread-&gt;clear_pending_exception(); java_lang_Thread::set_thread_status(threadObj(), java_lang_Thread::TERMINATED); java_lang_Thread::set_thread(threadObj(), NULL); //同志们看到了没，别的不用看，就看这一句，妈了个淡淡，//thread就是当前线程，是啥是啥？就是刚才说的b线程啊。 lock.notify_all(thread); thread-&gt;clear_pending_exception();&#125; 这样整个过程就清晰了。t1执行完了之后，对t1内置锁执行了notifyAll(),所有t2被唤醒，执行完成。 1.5 wait-notify/notifyAll 和 循环检测等待的区别之前有说过，wait和notify可以类似个等待通知，其实不用wait-notify模式也是可以做的，例如现有如下场景： A让B帮自己去买包烟回来，A等到B把烟买回交给自己的时候，A才给B钱 wait-notify的模式 A中1234while(!isGetCigarette) &#123; //没有得到烟 cigarette.wait(0)&#125;giveMoneyToB(); B中12// 如果自己买到烟,就通知A cigarette.notify() 不用wait-notify A中1234while(!isGetCigarette) &#123; //没有得到烟 // doNothing&#125;giveMoneyToB(); B中 123// 如果自己买到烟就设置标识为trueisGetCigarette = true; 两种都要求isGetCigarette是一个共享的变量。 那么这两种有什么区别呢 ？ 如果没有区别，是不是wait-notify岂不是没有存在意义 ？ 原因就在于：处于wait()中的线程是中断的，被挂起的，不会抢占cpu的计算时间；而相反的，无线循环保证了线程的就绪态，会占用cpu时间。占用cpu即会减少其他线程的计算资源，导致性能下降","categories":[{"name":"语言基础","slug":"语言基础","permalink":"http://yoursite.com/categories/语言基础/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"}]},{"title":"Java线程、线程池、并发包(1)","slug":"thread-01","date":"2018-01-10T14:02:13.000Z","updated":"2018-01-16T03:03:06.058Z","comments":true,"path":"2018/01/10/thread-01/","link":"","permalink":"http://yoursite.com/2018/01/10/thread-01/","excerpt":"","text":"1 线程的一些基本概念 编写线程安全的代码，其核心在于要对状态访问进行管理，特别是对共享（Shared）和可变（Mutable）状态的访问 （引自：《Java并发编程实战》） 从非正式的意义上来说，对象的状态是指存储在状态变量（例如示例或静态域）中的数据 （引自：《Java并发编程实战》） 1.1 共享(Shared)与可变(Mutable) “共享” 意味着变量可以由多个线程同时访问，二“可变”则意味着变量的值在其生命周期内可以发现变化 （引自：《Java并发编程实战》） 这些可变的变量在被多个线程访问的时候，如何防止这些改变不受控制,解决方法如下： 1、不在线程中共享该状态变量，可以将变量封装到方法中。 2、将状态变量修改为不可变的变量（final）。 3、访问状态变量时使用同步策略。 4、使用原子变量类。 1.2 线程安全性 线程安全是一个比较复杂的概念。其核心概念就是正确性。所谓正确性就是某各类的行为与其规范完全一致，即其近似与“所见即所知（we know it when we see it）”。当多个线程访问某各类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或者协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。 （引自：《Java并发编程实战》） 1.3 原子性、可见性、有序性原子性：一个操作如果是不可分割的，那么这个操作可以被认为是具有原子性的 可见性：线程可见性是指线程之间的可见性，即一个变量的修改对另外一个线程是可见的，这个变量的修改结果，另外一个线程可以立马知道。 有序性：有序性指的是数据不相关的变量在并发的情况下，实际执行的结果和单线程的执行结果是一样的，不会因为重排序的问题导致结果不可预知。volatile, final, synchronized，显式锁都可以保证有序性。 2 关于锁2.1 synchronized (内置锁)java内置的锁机制synchronized 可以用来保证原子性 同步代码块包括两个部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。以synchronized关键字来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的synchronized方法已Class对象作为锁 每个java对象都可以用作一个实现同步的锁，这些锁被称为 内置锁(Intrinsic Lock)或者监视器锁(Monitor Lock)。 也就是说内置锁是在java对象上面的，普通代码块还在synchronized(内置锁对象) 。同步方法就是在方法调用对象上加锁的 。 获取【内置锁】的唯一方式就是进入同步锁的代码块或者方法 java的内置锁是一种互斥锁，这就意味着最多只能有一个线程能持有这种锁。当线程A尝试说去线程B持有的锁的时候，线程A必须等待或者阻塞，直到线程B释放这个锁，否则A就一直等待下去。 例如上面的特性，可以实现一个死锁的例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445public class DeadLockDemo &#123; public static void main(String[] args) &#123; DeadLockDemo d = new DeadLockDemo(); Thread a = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"thread a running...\"); synchronized (d) &#123; // 获得对象d的锁 System.out.println(\"thread a get the lock...\"); while (true) &#123; // 只是简单的死循环，占用对象d的锁不释放 &#125; &#125; &#125; &#125;); Thread b = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"thread b running...\"); synchronized (d) &#123; // 获得对象d的锁 System.out.println(\"thread b get the lock...\"); &#125; &#125; &#125;); a.start(); try &#123; Thread.sleep(3000); // 确保a先启动，直接顺序start不能保证a比b先启动 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; b.start(); &#125;&#125;// output/*thread a running...thread a get the lock...thread b running...*/ 上面的例子，线程b一直都没有获得锁，一直等待a释放锁，从而导致死锁 2.2 内置锁的重入内置锁是可以重入的，也就是说某个线程试图获取他自己持有的锁的时候，这个请求会成功。 “重入”意味着获取锁的操作粒度是“线程”，而不是“调用” 例如：12345678910111213141516171819202122232425262728293031323334353637/** * 测试锁的重入 * * @author fun * @version v0.0.1 * @date 2017-03-22 12:02 */public class LockOverride &#123; public static class SuperClass &#123; public synchronized void doSomething() &#123; System.out.println(\"super do something....\"); &#125; &#125; public static class SubClass extends SuperClass &#123; @Override public synchronized void doSomething() &#123; System.out.println(\"sub do something and call super.doSomething()....\"); super.doSomething(); System.out.println(this); System.out.println(super); &#125; &#125; public static void main(String[] args) &#123; SubClass sub = new SubClass(); sub.doSomething(); &#125;&#125;// output/*sub do something and call super.doSomething()....super do something....*/ 可以看到，正常打印了结果，分析一下这个代码，在sub.doSomething的是时候和super.doSomething 的时候都需要获得SuperClass的锁，如果锁不能重入的话，就会一直等待，出现死锁。 这个是《java并发编程实践》中对所重入的例子，网上也很多地方都是这个例子，但是我不太理解，子类在调用doSomething的时候，获取应该是子类实例对象的锁才对啊，当运行到super.doSomething的时候，获取父类的内置锁，不冲突啊 ？ 一直很不解 所有我自己根据锁的理解和重入理解，写了个简单点的例子1234567891011121314151617181920212223242526/** * 测试锁的重入 * * @author yehuan * @version v0.0.1 * @date 2017-03-22 12:02 */public class LockOverride &#123; public static void main(String[] args) &#123; LockOverride lo = new LockOverride(); synchronized (lo) &#123; // 1 System.out.println(\"outter get lock on lo....\"); synchronized (lo) &#123; // 2 System.out.println(\"inner get lock on lo\"); &#125; &#125; &#125;&#125;//output/*outter get lock on lo....inner get lock on lo*/ 结果很明显，两次(注释1，2)同步块入口，获取锁成功了。但是1和2获取同一个锁，没等1释放，2就获得了。应为锁重入，2的时候已经有获得lo的内置锁了。 但是，如果上面代码变成如下方式，即2出变成一个新的线程呢：1234567891011121314151617181920212223242526272829public class LockOverride &#123; public static void main(String[] args) &#123; LockOverride lo = new LockOverride(); synchronized (lo) &#123; // 1 System.out.println(\"outter get lock on lo....\"+System.currentTimeMillis()); new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (lo) &#123; // 2 System.out.println(\"inner get lock on lo...\"+System.currentTimeMillis()); &#125; &#125; &#125;).start(); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;// outputoutter get lock on lo....1490166261911inner get lock on lo...1490166266912 这是时候获取锁的1,2两处实际上是两个线程，所有2等到1释放才执行了里面的代码。这也解释了上面说的锁的获取操作粒度是线程而不是调用。对比也解释了前面的例子能获得锁是因为同一个线程+锁的重入","categories":[{"name":"语言基础","slug":"语言基础","permalink":"http://yoursite.com/categories/语言基础/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"}]},{"title":"利用 Hexo 和 GitHub Page搭建个人博客","slug":"hello-world","date":"2018-01-03T14:02:13.000Z","updated":"2018-01-08T02:54:28.776Z","comments":true,"path":"2018/01/03/hello-world/","link":"","permalink":"http://yoursite.com/2018/01/03/hello-world/","excerpt":"","text":"Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Java不得不提的内存模型","slug":"jvm","date":"2017-03-31T16:00:00.000Z","updated":"2018-01-16T02:27:10.000Z","comments":true,"path":"2017/04/01/jvm/","link":"","permalink":"http://yoursite.com/2017/04/01/jvm/","excerpt":"","text":"1 认识JVM 1.1 程序计数器（program count register）当前线程执行的字节码的行号指示器。多线程时，当线程数超过CPU数量或CPU内核数量，线程之间就要根据时间片轮询抢夺CPU时间资源，因此每个线程有要有一个独立的程序计数器，记录下一条要运行的指令 程序计数器内存区域又称“线程私有”内存。 线程执行java方法，program count register 记录正在执行的虚拟机字节码指令的地址。程序执行Native方法，program count register 的值为空（Undefined），program count register是唯一一个在java虚拟机规范中没有定义OutOfMemoryError情况的区域 1.2 虚拟机栈（VM stack）线程私有的，与线程在同一时间创建。生命周期与线程相同 管理JAVA方法执行的内存模型。每个方法执行时都会创建一个桢栈来存储方法的的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。 栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法，-Xss参数可以设置虚拟机栈大小）。栈的大小可以是固定的，或者是动态扩展的。如果请求的栈深度大于最大可用深度，则抛出stackOverflowError；如果栈是可动态扩展的，但没有内存空间支持扩展，则抛出OutofMemoryError。 使用jclasslib工具可以查看class类文件的结构。 常说的栈内存、堆内存中的栈内存就是说的这个区域 下图为栈帧结构图： 1.3 本地方法栈（Native method stack）和虚拟机栈功能相似，但管理的不是JAVA方法，是本地方法，本地方法是用C实现的。 1.4 java堆 (JAVA Heap) 线程共享的，存放所有对象实例和数组。垃圾回收的主要区域。可以分为新生代和老年代(tenured)。 新生代用于存放刚创建的对象以及年轻的对象，如果对象一直没有被回收，生存得足够长，老年对象就会被移入老年代。 新生代又可进一步细分为eden、survivorSpace0(s0,from survivor)、survivorSpace1(s1,to survivor)。刚创建的对象都放入eden,s0和s1都至少经过一次GC并幸存。如果幸存对象经过一定时间仍存在，则进入老年代(tenured)。 物理上不要求连续，逻辑上连续即可。当堆中没有内存分配的时候，并且主机没有空间给堆来扩展的时候，出现 OutOfMemoryError 1.5 方法区 (Method Area)线程共享的，用于存放被虚拟机加载的类的元数据信息：如常量、静态变量、即时编译器编译后的代码。也成为永久代。如果hotspot虚拟机确定一个类的定义信息不会被使用，也会将其回收。回收的基本条件至少有：所有该类的实例被回收，而且装载该类的ClassLoader被回收 1.5.1 运行时常量池运行时常量池是方法去的一部分，Class文件中除了有类型版本、字段、方法、接口等信息外，还有常量池（Constant Pool table）信息，用于存放编译期生成的各种字面量和符号引用。 2. 垃圾回收算法2.1 判断对象是不是“死亡” 引用计数算法 对象有一个引用计数器，有引用+1，引用失效-1 缺点，不能解决相互引用的问题 可达性分析算法 GC Roots作为起点向下搜索，走过的路径为引用链。 当一个对象没有引用链到GC Roots时候就被判定为可回收对象 GC Roots 对象包括： VM Stack（本地变量表）中引用的对象 Method Area中类静态属性引用的对象 Method Area中常量引用的对象 Native Method Stack中JNI引用的对象 2.2 垃圾收集算法2.2.1 标记-清除算法（Mark-Sweep）【实现】：分为标记和清除两个步骤，标记算法即 引用计数算法 和 可达性分析算法 【优缺点】： 效率不高，标记和清除效率不高。 空间问题，清除算法过后，产生大量不连续的空间，碎片太多导致大对象进来的时候没有合适地方，导致提前再触发一次GC 2.2.2 复制算法(Copying) 【实现】：把内存容量分为两半，每次在一块上面操作，当一块用完，把所有存活的对象顺序复制到另外一块上，当前这一块全部清除。如此重复，新的一块上面也是连续的。 【优缺点】： 优点：效率高，实现简单，每次移动堆定指针即可，整块清除，不用处理内存碎片 缺点：空间问题，把原本的可用空间缩小了一半 【改进版】：大部分情况下，新生代对象98%都是“朝生夕死”的 ，所以内存比例划分不用1:1，而是一个大的Eden 和两个小的 Survivor, 每次只使用Eden 和 一个 Survivor。回收时，把Eden和Survivor的存活对象复制到另外的Survivor,如果存活对象比较多，就放到老年代。 HotSpot默认Eden:Survivor=8:1 此算法针对新生代 2.2.3 标识-整理算法（Mark-compact）【实现】：分标记和整理两步，标记: 引用计数算法 和 可达性分析法 ，整理:把存活对象向一段移动，再清除另一端的对象。 【优缺点】： 改进了标记清除算法的空间不连续问题 确定同标记清除一样，移动需要操作，效率问题 2.2.4 分代收集算法（Generational Collection）【实现】：根据对象存活周期不同，划分成新生代和老年代。在根据特点采用算法新生代使用复制算法，老年代中存活率高，没有额外控制，则使用“标记-清除”或者“标记-整理” 【优缺点】： 根据对象存活周期，灵活使用算法 2.2.5 理解GC日志虚拟机配置参数：-XX:+PrintGCDateStamps -XX:+PrintGCDetails 可以查看gc的日志，例如：122017-02-16T14:44:55.161+0800: [GC (System.gc()) [PSYoungGen: 6512K-&gt;680K(34816K)] 6512K-&gt;688K(114176K), 0.0031955 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 2017-02-16T14:44:55.165+0800: [Full GC (System.gc()) [PSYoungGen: 680K-&gt;0K(34816K)] [ParOldGen: 8K-&gt;615K(79360K)] 688K-&gt;615K(114176K), [Metaspace: 3167K-&gt;3167K(1056768K)], 0.0133387 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] GC日志开头的“[GC” 和 “[Full GC” 表示垃圾收集的停顿类型，Full GC 表示发生了Stop The World PSYoungGen、ParOldGen、Metaspace 表示GC发现的区域，具体名字跟收集器相关，方括号内部“680K-&gt;0K(34816K)” 表示 “GC前该区域的内存已使用量-&gt;GC后该区域的内存已使用量(改内存区域总量)” 方括号外的“688K-&gt;615K(114176K)” 表示“GC前java堆已使用的容量-&gt;GC后java堆的已使用容量(java堆的总容量)” 在 HandlePromotionFailure设置是否允许担保失败，开启开关后，比较的是历次晋升到老年代对象的平均值 如果HandlePromotionFailure失败，会触发一次Full GC。打开HandlerPromotionFailure设置，可避免Full GC过于频繁 3. OutOfMemoryError实战3.1 java heap 溢出【要点】： -Xms -Xmx 设置堆的大小 -XX:+HeapDumpOnOutOfMemoryError 是vm dump出日志，可供分析 【应对】： 分时dump日志，看看是内存泄露（回收不了）还是内存溢出（内存不够） 如果是内存泄露，通过工作找到泄露对象通过什么引用链关联导致不能回收，处理代码 如果是内存不够，结合物理机内存，适当调整-Xms -Xmx的大小 优化代码，减少生命周期长，持有状态时间长的代码 3.2 VM stack和 Native method stack 溢出【要点】： 使用-Xss 设置栈的容量 线程请求栈的深度大于虚拟机允许的深度，抛出StackOverflowError 虚拟机栈扩展的时候不能获得足够空间，抛出OutOfMemoryError 【应对】： 在单线程的情况下基本很难出现OutOfMemoryError，基本都只能达到StackOverflowError。多线程的时候可以出现OutOfMemoryError，单个栈的空间大了，多线程的时候，线程使用的空间多了，占用的内存就多了，就会OutOfMemoryError。因此如果是多线程导致OutOfMemoryError可以尝试适当减小栈内存来尝试解决 3.3 method area 和 constant pool table 溢出【要点】：方法区存放的是 Class相关信息，类名，访问修饰符，常量池，字段描述，方法描述等。 在运行时动态产生大量对象有可能造成OOM 【应对】：使用CGlib ，大量JSP 后者动态JSP文件的应用，基于OSGi的应用等都是可能出现OOM,代码需要注意 3.4 本机直接内存溢出(DirectMemory)【要点】：通过 -XX:MaxDirectMemorySize 设置。由于DirectMemory 导致的内存溢出，一个明显的特点就是dump文件中看不出来明显异常。 【应对】：如果发现OOM之后dump文件很小，程序中如果直接或者间接使用了NIO,则可能是NIO这方面的使用有问题 4. JVM参数：1234567891011-XX:+PrintGCDetails 打印垃圾回收信息-Xms 为Heap区域的初始值，线上环境需要与-Xmx设置为一致，否则capacity的值会来回飘动-Xmx 为Heap区域的最大值-Xss（或-ss） 线程栈大小（指一个线程的native空间）1.5以后是1M的默认大小-XX:PermSize与-XX:MaxPermSize 方法区（永久代）的初始大小和最大值（但不是本地方法区）-XX:NewRatio 老年代与新生代比率-XX:SurvivorRatio Eden与Survivor的占用比例。例如8表示，一个survivor区占用 1/8 的Eden内存，即1/10的新生代内存，为什么不是1/9？因为我们的新生代有2个survivor，即S1和S2。所以survivor总共是占用新生代内存的 2/10，Eden与新生代的占比则为 8/10。-XX:MaxHeapFreeRatio GC后，如果发现空闲堆内存占到整个预估的比例小于这个值，则减小堆空间。-XX:MinHeapFreeRatio GC后，如果发现空闲堆内存占到整个预估的比例大于这个值，则增大堆空间。-XX:NewSize 新生代大小 5. 内存分配内存分配算法： 指针碰撞(Bump the pointer)（空闲区和不可用区有一个指针分开，内存是规整的） 空闲列表(Free List)（虚拟机维护一个空闲列表，每次从列表中找出一个足够的空间，并更新列表） 对象访问定位：目前主流访问方式有 使用句柄访问 和 直接指针 1 使用句柄访问 2 直接指针 两张访问方式各有优劣 句柄访问访问最大好处就是稳定的句柄，GC收集的时候只会改变句柄中的实例指针，而reference本身不变 直接方式就是直接访问，速度快","categories":[{"name":"语言基础","slug":"语言基础","permalink":"http://yoursite.com/categories/语言基础/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"浅析Java序列化问题","slug":"serializable","date":"2017-03-28T16:00:00.000Z","updated":"2018-01-05T17:09:02.453Z","comments":true,"path":"2017/03/29/serializable/","link":"","permalink":"http://yoursite.com/2017/03/29/serializable/","excerpt":"","text":"1. 为什么要序列化java序列化的目的就是把一个对象转换成流，并通过网络发送，或将其存入文件或者数据库以便未来使用。反序列则是把流转化成实际程序中使用的java。 Java的”对象序列化”能让你将一个实现了Serializable接口的对象转换成一组byte，这样日后要用这个对象时候，你就能把这些byte数据恢复出来，并据此重新构建那个对象了。这一点甚至在跨网络的环境下也是如此，这就意味着序列化机制能自动补偿操作系统方面的差异。也就是说，你可以在Windows机器上创键一个对象，序列化之后，再通过网络传到Unix机器上，然后在那里进行重建。你不用担心在不同的平台上数据是怎样表示的，byte顺序怎样，或者别的什么细节。之所以需要对象序列化，是因为有时候对象需要在网络上传输，传输的时候需要这种序列化处理，从服务器硬盘上把序列化的对象取出，然后通过网络传到客户端，再由客户端把序列化的对象读入内存，执行相应的处理。 2. 序列化实现及原理在java jdk1.1中就引入了序列化api。如果你希望一个类对象是可序列化的，你所要做的是实现java.io.Serializable接口。序列化一种标记接口，不需要实现任何字段和方法，这就像是一种选择性加入的处理，通过它可以使类对象成为可序列化的对象。 序列化处理是通过ObjectInputStream和ObjectOutputStream实现的，因此我们所要做的是基于它们进行一层封装，要么将其保存为文件，要么将其通过网络发送 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Foo implements Serializable&#123; public static int w = 1; public static transient int x = 2; public int y = 3; public transient int z = 4;&#125;public class TransDemo &#123; public static void main(String[] args) &#123; Foo foo = new Foo(); System.out.printf(\"w: %d%n\", Foo.w); System.out.printf(\"x: %d%n\", Foo.x); System.out.printf(\"y: %d%n\", foo.y); System.out.printf(\"z: %d%n\", foo.z); FileOutputStream fos = null; try &#123; fos = new FileOutputStream(\"x.ser\"); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(foo); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; Foo fooNew = null; FileInputStream fis = null; try &#123; fis = new FileInputStream(\"x.ser\"); ObjectInputStream ois = new ObjectInputStream(fis); System.out.println(); fooNew = (Foo) ois.readObject(); // 上面代码执行完后，可以看到fooNew的属性中只有y=3,z=0 ,页验证了static 和 transient 不被序列化。 // 查看源码writeObject上面的注释也写明了 System.out.printf(\"w: %d%n\", fooNew.w); System.out.printf(\"x: %d%n\", fooNew.x); System.out.printf(\"y: %d%n\", fooNew.y); System.out.printf(\"z: %d%n\", fooNew.z); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 上面的示例是一个使用序列化的例子。从上面的例子可以看出: 如果想避免属性被序列化的话，将属性申明为static 或 transient就可以了。 为什么呢？查看源码ObjectOutputStream和ObjectInputStream就会发现，序列化实现就是依靠这两个类来做的。 查看ObjectOutputStream的 writeObject 方法，上面明显的注释说明，一个类的non-static属性和non-transient属性会被序列化。 序列化的过程 ObjectOutputStream.writeObject--&gt;writeObject0--&gt;writeOrdinaryObject--&gt;writeSerialData--&gt;defaultWriteFields--&gt;writeObject0 可以看出，是一个递归的调用，也就是说被序列化的对象如果有嵌套的实现了序列化接口的用户对象，他也会被序列化。 3. 序列化版本uid1private static final long serialVersionUID = -1L; serialVersionUID这个在实现序列化的类里面很常见，这个实际上就是一个数据版本号，已经序列化的数据在反序列化的时候，如果对象的版本已经修改了，反序列化就会出现错误。其实就是数据独享版本的控制，相同版本的才能正常反序列化。 把上的示例完善点： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Foo implements Serializable&#123; private static final long serialVersionUID = -1L;// 注释① public static int w = 1; public static transient int x = 2; public int y = 3; public transient int z = 4;&#125;public class TransDemo &#123; public static void main(String[] args) &#123; TransDemo test = new TransDemo(); Foo foo = new Foo(); System.out.println(\"-----before serialize:\"); test.printObject(foo); test.putSerializedObject(foo); // 注释② System.out.println(\"-----after serialize:\"); test.printObject(test.getSerializedObject()); &#125; public void putSerializedObject(Foo foo) &#123; FileOutputStream fos = null; try &#123; fos = new FileOutputStream(\"x.ser\"); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(foo); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public Foo getSerializedObject() &#123; Foo fooNew = null; FileInputStream fis = null; try &#123; fis = new FileInputStream(\"x.ser\"); ObjectInputStream ois = new ObjectInputStream(fis); System.out.println(); fooNew = (Foo) ois.readObject(); return fooNew; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; public void printObject(Foo foo) &#123; System.out.printf(\"w: %d%n\", foo.w); System.out.printf(\"x: %d%n\", foo.x); System.out.printf(\"y: %d%n\", foo.y); System.out.printf(\"z: %d%n\", foo.z); &#125;&#125; 上面的示例，第一次直接执行，第二字只做反序列化，并且修改了序列化对象的版本号，即操作注释①的uid=-2L ,注释掉 注释②出的代码。只反序列化。这个时候就提提示异常了： 1java.io.InvalidClassException: com.fun.lang.Foo; local class incompatible: stream classdesc serialVersionUID = -1, local class serialVersionUID = -2","categories":[{"name":"语言基础","slug":"语言基础","permalink":"http://yoursite.com/categories/语言基础/"}],"tags":[{"name":"序列化","slug":"序列化","permalink":"http://yoursite.com/tags/序列化/"}]},{"title":"你以为你熟悉的java关键字","slug":"java关键字","date":"2017-03-17T15:46:00.000Z","updated":"2018-01-05T17:08:51.818Z","comments":true,"path":"2017/03/17/java关键字/","link":"","permalink":"http://yoursite.com/2017/03/17/java关键字/","excerpt":"","text":"1 static 使用StaticDemo的任何方法（静态或者非静态方法），static代码块仅且执行一次 非静态成员方法可以操作静态成员变量的值 构造方法只在new 关键字出现，new新的对象的时候调用，使用类名直接调用静态方法的时候没有调用构造方法 static不能用来修饰普通内部类中的变量，如果内部类本身是static的是可以的 1234567891011121314151617181920public class StaticDemo &#123; private static String prop = null; static&#123; prop = \"static\"; System.out.println(\"static code block.......\"); &#125; public StaticDemo()&#123; prop = \"constructor\"; System.out.println(\"constructor.......\"); &#125; public static void sayHello()&#123; System.out.println(\"sayHello method print the prop=\"+prop); &#125; public void sayHello2()&#123; prop = \"sayHello2\"; System.out.println(\"sayHello2 method print the prop=\"+prop); &#125;&#125; 2 final在java中，可能使用到final关键字修饰的有数据、方法和类。 2.1 final 修饰数据有final修饰的数据是用来告诉编译器一块数据是恒定不变的，有时数据恒定不变是很有用的，比如： 一个永不改变的编译时常量。 一个在运行时被初始化的值，但是又不希望它被改变。 编译时常量必须是基本数据类型，并且以关键字final修饰，在对这个常量进行定义的时候必须进行赋值，并且以后不能被改变。 对于基本类型，final使数值恒定不变；而对于对象引用，final使引用恒定不变，也就是说某个引用不能再指向其他对象了，但是当前指向的这个对象自身的数据是可以改变的。 如何理解上面的解释呢，看如下示例： 12345678public void test(final Student student) &#123; // 这种写法就会报错，因为改变了student的指向，但是student是个final的。 // student = new Student() // 这种操作是可以的，并且student的name会被成功修改 student.setName(\"123\"); &#125; 2.2 final修饰方法 使用final修饰方法的作用是把方法锁定，以防止任何继承类修改它的含义。在继承类中，使用了与父类用final修饰的方法同名的方法时，并没有覆盖父类的该方法，而是生成了一个新的方法。也就是说final修饰的方法不能被重写。 2.3 final修饰类 当将某个类定义为final时，就表明了你不打算继承该类，也不允许别人继承。 3 transient使用transient 关键字，标记变量不被序列化和反序列化 谈到序列化，static 变量也是不会被序列化的 4 volatilevolatile 可以保证变量对所有线程的可见性，但是不能说是完全的线程，例如++ 操作是个非原子操作，就有可能出现问题 volatile只保证了可见性，在不满足以下情况的时候，需要加锁（synchronized 或者 java.util.concurrent中的原子类）来保证原子性 运算结果并不依赖变量的当前值，后者能够确保只有单一线程修改变量的值 变量不需要同其他的状态变量一起参与不变约束 volatile 修饰long / double 在多线程的时候可以把他们的读写变成原子的操作(现代的虚拟机已经把64位数据读写作为原子操作了) volatile可以防止指令重排序","categories":[{"name":"语言基础","slug":"语言基础","permalink":"http://yoursite.com/categories/语言基础/"}],"tags":[{"name":"static","slug":"static","permalink":"http://yoursite.com/tags/static/"}]},{"title":"Java的基础核心-集合","slug":"array-collection","date":"2017-03-16T14:02:13.000Z","updated":"2018-01-16T02:34:43.000Z","comments":true,"path":"2017/03/16/array-collection/","link":"","permalink":"http://yoursite.com/2017/03/16/array-collection/","excerpt":"","text":"1. 数组数组是一个特殊对象 网上找到的学习资料，java基础总结的比较完善的一位http://www.cnblogs.com/chenssy/category/525010.html 数组性能比起list和set,效率高，单操作没有他们方便 ArrayList的扩容的方式中使用copyOf方法，按照此方法可以实现数据的动态长度 Arrays的方法中 copyOf 和asList 需要注意 . asList的返回值是 Arrays.ArrayList 其父类是 AbstractList ,其中对 add()/remove等方法都是没有实现的。所以都是直接返回UnsupportedOperationException 这个内部类ArrayList并没有提高add的实现方法。在ArrayList中，它主要提供了如下几个方法： size：元素数量 toArray：转换为数组，实现了数组的浅拷贝。 get：获得指定元素。 contains：是否包含某元素。 所以综上所述，asList返回的是一个长度不可变的列表。数组是多长，转换成的列表是多长，我们是无法通过add、remove来增加或者减少其长度的。 2.集合关于集合的整体上面的理解，参考http://www.cnblogs.com/chenssy/p/3495238.html 图片来自http://images.cnitblog.com/blog/381060/201312/28124706-794c0dc2df43446c85b93d7864119334.png 2.1 List接口 List接口为Collection直接接口。List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。 2.1.1 ArrayList 初始大小为10，没已1.5进行扩容，扩容的时候使用的是Arrays.copyOf (System.arraycopy),所有指定大小可以避免不必要的扩容操作，同时可以避免扩容的时候空间多余 数组形式，适合快速定位查找。 非线程安全 2.1.2 LinkedList 双向的链表。 非线程安全 首尾添加操作时候速度快，里面保存了最后一个节点(last)和第一个节点(first)的引用 2.1.3 Vector类似ArrayList 但是操作都是在方法加了同步锁的，所以的线程安全的，同样是因为加了同步锁，整体效率会较ArrayList弱点 2.1.4 Stack Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。 2.2 Map接口Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。实现map的有：HashMap、TreeMap、HashTable、Properties、EnumMap。 2.2.1 HashMapHashMap 非线程安全，访问快 2.2.1.1 内部结构1. Entry table 内部是一个实现了Map.Entry接口的静态内部类的数组。123456789/** * An empty table instance to share when the table is not inflated. */ static final Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;; /** * The table, resized as necessary. Length MUST Always be a power of two. */ transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE; 值得注意的是，Entry实际上是一个链表，所以HashMap可以看做一个链表数组12345static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash; 2. 关键概念 size : map中key-value的数量 loadFactor：加载因子 ,其中默认加载因子 DEFAULT_LOAD_FACTOR=0.75f threshold：阀值，超过阀值的时候需要扩容，默认Integer.MAX_VALUE capacity: 容量,构造方法传入或者默认值16，上限 (1 &lt;&lt; 30) 1threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1); 3. 关于扩容 每次加入数据的时候会计算Hash值，并检测是否超过阀值而要扩容。当size&gt;=threshold的时候就会扩容，每次扩大2倍的table.length。扩容的时候实际是遍历原来的table数据重新计算hash后放到新的size的table中。 2.2.1.2 定位存放位子（table中的下标）元素在table数组中的下标计算方式是使用hash() 方法的值与table的length-1进行&amp;运算（indexFor()方法） 插入数据的时候，要检测key时候重复，没有重复的时候，如果index的位子有元素，则新的元素插入在链表头部。 get(Object key) 方法的实现，其实就是对key做hash处理之后，在调用indexFor得到在table中的下标。在往后找，找到equals的值返回。 2.2.2 TreeMap红黑树实现，内部是有序的，在要求一个有序的map的是时候用比较的合适，效率上比HashMap弱一点。毕竟构建红黑的树的过程不是很简单 1// todo: 源码分析，待完善 2.2.3 Hashtable继承的是Dictionary ,HashMap继承是AbstractMap，实现的接口都一样 基本思想和HashMap差不多，但是put和get等操作方法上加了同步锁，所以是相对线程安全的，但是效率较HashMap弱 2.3 Set接口Set元素不重复，可以是null,自己维护内部顺序 2.3.1 EnumSet内部元素必须是enum 类型 2.3.2 HashSet内部其实就一个HashMap , set里面的每个元素被作为HashMap的key,set的操作其实就是对内部的HashMap的key的操作。 2.3.3 TreeSetTreeSet 里面就是一个实现了 NavigableMap接口的map,通常就是TreeMap。 它是使用元素的自然顺序对元素进行排序，或者根据创建Set 时提供的 Comparator 进行排序，具体取决于使用的构造方法。 2.4 Queue接口 队列，它主要分为两大类，一类是阻塞式队列，队列满了以后再插入元素则会抛出异常，主要包括ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue。另一种队列则是双端队列，支持在头、尾两端插入和移除元素，主要包括：ArrayDeque、LinkedBlockingDeque、LinkedList。 源自 http://www.cnblogs.com/chenssy/p/3495238.html 其中ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue 为java.util.concurrent 包中的类","categories":[{"name":"语言基础","slug":"语言基础","permalink":"http://yoursite.com/categories/语言基础/"}],"tags":[{"name":"集合类","slug":"集合类","permalink":"http://yoursite.com/tags/集合类/"}]},{"title":"变幻莫测的Java内部类","slug":"inner-class","date":"2017-02-13T14:02:13.000Z","updated":"2018-01-16T02:44:34.000Z","comments":true,"path":"2017/02/13/inner-class/","link":"","permalink":"http://yoursite.com/2017/02/13/inner-class/","excerpt":"","text":"1.1 内部类【特点】： 普通内部类中不能有static修饰的成员变量和方法 使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。利用内部类可以间接实现多继承。 (利用多个内部类实现继承过个类，思想是组合)。 内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。 创建内部类对象的时刻并不依赖于外围类对象的创建。 内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。 内部类提供了更好的封装，除了该外围类，其他类都不能访问。 1.2内部类【使用.this与.new】1234567891011121314151617181920212223242526public class OuterClass &#123; private String name ; private int age; /**省略getter和setter方法**/ public class InnerClass&#123; public InnerClass()&#123; name = \"chenssy\"; age = 23; &#125; public void display()&#123; System.out.println(\"name：\" + getName() +\" ;age：\" + getAge()); &#125; &#125; public static void main(String[] args) &#123; OuterClass outerClass = new OuterClass(); OuterClass.InnerClass innerClass = outerClass.new InnerClass(); innerClass.display(); &#125;&#125;--------------Output：name：chenssy ;age：23 引用内部类我们需要指明这个对象的类型：OuterClasName.InnerClassName。同时如果我们需要创建某个内部类对象，必须要利用外部类的对象通过.new来创建内部类： OuterClass.InnerClass innerClass = outerClass.new InnerClass(); 如果我们需要生成对外部类对象的引用，可以使用OuterClassName.this 1234567891011121314151617181920public class OuterClass &#123; public void display()&#123; System.out.println(\"OuterClass...\"); &#125; public class InnerClass&#123; public OuterClass getOuterClass()&#123; return OuterClass.this; &#125; &#125; public static void main(String[] args) &#123; OuterClass outerClass = new OuterClass(); OuterClass.InnerClass innerClass = outerClass.new InnerClass(); innerClass.getOuterClass().display(); &#125;&#125;-------------Output:OuterClass... 1.3 内部类【分类】1.3.1 成员内部类成员内部类也是最普通的内部类，它是外围类的一个成员 【特点】： 成员内部类中不能存在任何static的变量和方法； 成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类 1.3.2 局部内部类在方法和属性内部定义的类，作用域在方法和属性内部 1.3.3 匿名内部类比较常见 123456789101112131415161718192021222324public class OuterClass &#123; public InnerClass getInnerClass(final int num,String str2)&#123; return new InnerClass()&#123; int number = num + 3; public int getNumber()&#123; return number; &#125; &#125;; /* 注意：分号不能省 */ &#125; public static void main(String[] args) &#123; OuterClass out = new OuterClass(); InnerClass inner = out.getInnerClass(2, \"chenssy\"); System.out.println(inner.getNumber()); &#125;&#125;interface InnerClass &#123; int getNumber();&#125;----------------Output:5 【特点】： 匿名内部类是没有访问修饰符的。 new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。 使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法 1.3.3.1 使用的形参为何要final内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份，自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数 在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用final来避免形参的不改变。 1.3.3.2 匿名内部类初始化没有构造方法，所以使用构造代码块来创建达到构造方法的效果 123456789101112131415161718192021222324252627282930313233343536373839404142public class OuterClass &#123; private int id; private InnerClass getInnerClass(final String name, final int age) &#123; return new InnerClass() &#123; String innerName; int innerAge; // 构造代码块初始化 &#123; innerName = name; innerAge = age; &#125; @Override public String getInnerName() &#123; return innerName; &#125; @Override public int getInnerAge() &#123; return innerAge; &#125; &#125;; &#125; public static void main(String[] args) &#123; OuterClass outerClass = new OuterClass(); InnerClass innerClass = outerClass.getInnerClass(\"fun\",26); System.out.println(innerClass.getInnerName()); InnerClass innerClass2 = outerClass.getInnerClass(\"BruceLee\",26); System.out.println(innerClass2.getInnerName()); &#125;&#125;interface InnerClass&#123; String getInnerName(); int getInnerAge();&#125; 1.3.4 静态内部类使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类 静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。 所以有以下【特点】： 它的创建是不需要依赖于外围类的。 它不能使用任何外围类的非static成员变量和方法","categories":[{"name":"语言基础","slug":"语言基础","permalink":"http://yoursite.com/categories/语言基础/"}],"tags":[{"name":"内部类","slug":"内部类","permalink":"http://yoursite.com/tags/内部类/"}]}]}