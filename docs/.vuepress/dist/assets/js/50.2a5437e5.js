(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{680:function(t,e,r){"use strict";r.r(e);var a=r(4),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"netty的重要组件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#netty的重要组件"}},[t._v("#")]),t._v(" Netty的重要组件")]),t._v(" "),r("h2",{attrs:{id:"_1-eventloop、eventloopgroup"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-eventloop、eventloopgroup"}},[t._v("#")]),t._v(" 1 EventLoop、EventLoopGroup")]),t._v(" "),r("h2",{attrs:{id:"_2-bootstrap-serverbootstrap"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-bootstrap-serverbootstrap"}},[t._v("#")]),t._v(" 2 Bootstrap/ServerBootstrap")]),t._v(" "),r("h2",{attrs:{id:"_3-channelfuture、channel"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-channelfuture、channel"}},[t._v("#")]),t._v(" 3 ChannelFuture、Channel")]),t._v(" "),r("h2",{attrs:{id:"_4-channelhandler、channelpipline、channelhandlercontext"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-channelhandler、channelpipline、channelhandlercontext"}},[t._v("#")]),t._v(" 4 ChannelHandler、ChannelPipline、ChannelHandlerContext")]),t._v(" "),r("h2",{attrs:{id:"_5-编码器与解码器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-编码器与解码器"}},[t._v("#")]),t._v(" 5 编码器与解码器")]),t._v(" "),r("h3",{attrs:{id:"_5-1-tcp粘包-拆包问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-tcp粘包-拆包问题"}},[t._v("#")]),t._v(" 5.1 TCP粘包/拆包问题")]),t._v(" "),r("p",[t._v("TCP是个“流”协议，所谓流，就是没有界限的一串数据。大家可以想想河里的流水，它们是连成一片的，其间并没有分界线。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。")]),t._v(" "),r("p",[r("strong",[t._v("TCP 粘包/拆包发生的原因")]),t._v("：")]),t._v(" "),r("ol",[r("li",[t._v("应用程序write写入的字节大小 > 套接字接口发送缓冲区大小")]),t._v(" "),r("li",[t._v("进行MSS大小的TCP分段")]),t._v(" "),r("li",[t._v("以太网帧的payload大于MTU进行IP分片")])]),t._v(" "),r("p",[r("strong",[t._v("TCP 粘包问题解决策略")])]),t._v(" "),r("p",[t._v("一般都是通过在上层协议设计上来解决这个问题，业界主流方案如下：")]),t._v(" "),r("ol",[r("li",[t._v("消息定长，使用固定长度消息，不够空位补空格")]),t._v(" "),r("li",[t._v("在包尾部增加回车换行符进行分割，例如FTP协议")]),t._v(" "),r("li",[t._v("将消息分为消息头和消息体，消息头中包含消息总长度（或者消息体长度）的字段，通常设计思路为消息头的第一个字段使用int32来表示消息总长度")]),t._v(" "),r("li",[t._v("其他更加复杂的应用层协议")])]),t._v(" "),r("p",[t._v("在netty中，解决粘包、拆包问题最大的利器就是编码器和解码器。")]),t._v(" "),r("h3",{attrs:{id:"_5-1-编码器与解码器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-编码器与解码器"}},[t._v("#")]),t._v(" 5.1 编码器与解码器")]),t._v(" "),r("p",[t._v("LineBasedFrameDecoder")]),t._v(" "),r("p",[t._v("DelimiterDasedFrameDecoder")]),t._v(" "),r("p",[t._v("FixedLengthFrameDecoder")]),t._v(" "),r("h1",{attrs:{id:"_6-netty逻辑架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-netty逻辑架构"}},[t._v("#")]),t._v(" 6 Netty逻辑架构")]),t._v(" "),r("p",[t._v("参考资料：")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://juejin.im/post/5bea1d2e51882523d3163657",target:"_blank",rel:"noopener noreferrer"}},[t._v("一文理解Netty模型架构"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://waylau.gitbooks.io/netty-4-user-guide/",target:"_blank",rel:"noopener noreferrer"}},[t._v("netty-4-user-guide"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://www.infoq.cn/article/netty-threading-model",target:"_blank",rel:"noopener noreferrer"}},[t._v("Netty 系列之 Netty 线程模型"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://www.jianshu.com/nb/23688586",target:"_blank",rel:"noopener noreferrer"}},[t._v("Netty & 网络(作者：益文的圈)"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=n.exports}}]);