(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{715:function(e,s,a){"use strict";a.r(s);var v=a(4),r=Object(v.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"分布式缓存-redis基础入门"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式缓存-redis基础入门"}},[e._v("#")]),e._v(" 分布式缓存：Redis基础入门")]),e._v(" "),a("hr"),e._v(" "),a("h2",{attrs:{id:"redis的持久化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis的持久化"}},[e._v("#")]),e._v(" redis的持久化")]),e._v(" "),a("p",[e._v("关于redis的安装和基本使用，参考博客：")]),e._v(" "),a("p",[a("a",{attrs:{href:"http://blog.csdn.net/fun913510024/article/details/46822943",target:"_blank",rel:"noopener noreferrer"}},[e._v("redis安装和基础入门"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://blog.csdn.net/fun913510024/article/details/47321993",target:"_blank",rel:"noopener noreferrer"}},[e._v("Redis数据库的学习与实践—Redis的常用命令及高级应用"),a("OutboundLink")],1)]),e._v(" "),a("ol",[a("li",[e._v("RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。")]),e._v(" "),a("li",[e._v("AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。")])]),e._v(" "),a("p",[e._v("Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。")]),e._v(" "),a("p",[e._v("也可以关闭持久化功能，让数据只在服务器运行时存在。")]),e._v(" "),a("h3",{attrs:{id:"rdb-模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rdb-模式"}},[e._v("#")]),e._v(" RDB 模式")]),e._v(" "),a("h4",{attrs:{id:"配置方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#配置方式"}},[e._v("#")]),e._v(" 配置方式")]),e._v(" "),a("p",[e._v("RDB 复制模式也称作快照模式，在指定时间间隔中保存数据快照。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("save <seconds> <changes>\n")])])]),a("p",[e._v("在 seconds 时间间隔中发生changes次数的变化，就触发一次快照保存。可以配置多条规则。")]),e._v(" "),a("p",[e._v("除了在redis的配置文件中配置快照的规则外，还可以手动直接触发一次快照。直接调用"),a("code",[e._v("SAVE")]),e._v(" 或者 "),a("code",[e._v("BGSAVE")]),e._v("命令。")]),e._v(" "),a("h4",{attrs:{id:"工作原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#工作原理"}},[e._v("#")]),e._v(" 工作原理")]),e._v(" "),a("p",[e._v("当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作：")]),e._v(" "),a("ol",[a("li",[e._v("Redis 调用 fork() ，同时拥有父进程和子进程。")]),e._v(" "),a("li",[e._v("子进程将数据集写入到一个临时 RDB 文件中。")]),e._v(" "),a("li",[e._v("当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。")])]),e._v(" "),a("p",[e._v("这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益")]),e._v(" "),a("h4",{attrs:{id:"优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优缺点"}},[e._v("#")]),e._v(" 优缺点")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("优点")]),e._v(" "),a("ol",[a("li",[e._v("RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。")]),e._v(" "),a("li",[e._v("RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心。")]),e._v(" "),a("li",[e._v("RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。")]),e._v(" "),a("li",[e._v("RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。")])])]),e._v(" "),a("li",[a("p",[e._v("缺点")]),e._v(" "),a("ol",[a("li",[e._v("rdb模式按照指定时间发生几次变化来持久化数据，这就有可能在数据没有发生持久化的时候就宕机，导致当前时间段内的数据丢失")]),e._v(" "),a("li",[e._v("每次rdb回fork子进程进行，当数据量比较大的时候fork很耗时间，CPU紧张的时候更容易出现卡顿。")])])])]),e._v(" "),a("h3",{attrs:{id:"aof-appendonly-file-模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof-appendonly-file-模式"}},[e._v("#")]),e._v(" AOF(AppendOnly File) 模式")]),e._v(" "),a("p",[e._v("在服务器突然断电，死机，或者调用"),a("code",[e._v("kill -9")]),e._v(" 命令杀死redis的时候，使用rdb的方式持久化是不够，这个时候最新的操作是没有被持久化。因此redis提供另外的一种持久化方式，append-only file 。")]),e._v(" "),a("h4",{attrs:{id:"aof-配置方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof-配置方式"}},[e._v("#")]),e._v(" AOF 配置方式")]),e._v(" "),a("p",[e._v("要启动AOF的方式，需要在配置文件中设置")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("appendonly yes\n")])])]),a("p",[e._v("配置时候，redis没产生一条指令都会被追加到AOF文件中，当服务器重启的时候，redis就从这个文件中重新执行指令来回复数据到内存中。")]),e._v(" "),a("p",[a("strong",[e._v("aof重写")]),e._v("\n通过上面不难发现，如果每次执行指令被保存，aof文件会越来远大。例如，一个increment 100次，就有100条指令，但是实际可以在回复数据的时候调用一句"),a("code",[e._v("set")]),e._v(" 指令回复到最后的数据就可以了。所以redis也内置了重写机制。在不中断对客户端的服务器的情况下，在后台对aof文件重写。reids 2.2之前。需要是不是的调用"),a("code",[e._v("BGREWRIETAOF")]),e._v("指令，redis 2.4之后都是自动触发此指令。")]),e._v(" "),a("p",[a("strong",[e._v("同步频率配置 (how durable)")])]),e._v(" "),a("p",[e._v("多久把数据同步(fsync)一次到文件的策略有三种：")]),e._v(" "),a("ol",[a("li",[e._v("fsync always 每次新的指令，每条指令都加到aof。此方法非常非常的慢，但是非常安全。")]),e._v(" "),a("li",[e._v("fsync everysec每个一秒钟同步一次。这种方法速度很快，最坏情况是损失1s内的数据")]),e._v(" "),a("li",[e._v("never no 不同步，而是交给操作系统去处理。非常快，但是不安全。")])]),e._v(" "),a("p",[e._v("redis默认和推荐的方法是每秒同步方式。")]),e._v(" "),a("p",[a("strong",[e._v("配置方式")]),e._v("：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("# appendfsync always\nappendfsync everysec\n# appendfsync no\n")])])]),a("p",[a("strong",[e._v("AOF文件损坏怎么处理")]),e._v("\n当AOF文件损坏的时候，redis不能再从AOF中恢复数据，可按找下面的步骤处理：")]),e._v(" "),a("ol",[a("li",[e._v("备份当前AOF文件")]),e._v(" "),a("li",[e._v("使用redis-check-aof工具修复原AOF文件，执行命令 "),a("code",[e._v("redis-check-aof --fix")])]),e._v(" "),a("li",[e._v("选择性的使用"),a("code",[e._v("diff -u")]),e._v("检测两个文件的不同")]),e._v(" "),a("li",[e._v("用修改后的文件重启服务")])]),e._v(" "),a("h4",{attrs:{id:"aof-工作原理-rewrite"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof-工作原理-rewrite"}},[e._v("#")]),e._v(" AOF 工作原理（rewrite）")]),e._v(" "),a("ol",[a("li",[e._v("redis forks 一个子进程")]),e._v(" "),a("li",[e._v("子进程开始把AOF写到一个临时文件")]),e._v(" "),a("li",[e._v("父进程计算所有的新变化并放在一个内存缓冲区（同时他还把这些变化写进老的AOF文件，所以重写失败，也是安全的）")]),e._v(" "),a("li",[e._v("最后。redis自动用新文件替换老文件。开始往新文件添加数据")])]),e._v(" "),a("h4",{attrs:{id:"aof-优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof-优缺点"}},[e._v("#")]),e._v(" AOF 优缺点")]),e._v(" "),a("p",[a("strong",[e._v("AOF 优点")]),e._v("：")]),e._v(" "),a("ol",[a("li",[e._v("数据安全性更高，从同步机制上看。always方式满，但每条指令都存储。")]),e._v(" "),a("li",[e._v("aof是一个追加文件，出现问题可以使用redis-check-aof工具修复")]),e._v(" "),a("li",[e._v("文件过大的时候会使用重写方式，只要文件存在，数据有可以恢复")]),e._v(" "),a("li",[e._v("文件内容以redis的协议存储，方便解读。能偶方便导出和解析。")])]),e._v(" "),a("p",[a("strong",[e._v("AOF 缺点")]),e._v("：")]),e._v(" "),a("ol",[a("li",[e._v("数据量过大的时候，redis的aof体积会比rdb文件大")]),e._v(" "),a("li",[e._v("根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）")])]),e._v(" "),a("h2",{attrs:{id:"数据容灾"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据容灾"}},[e._v("#")]),e._v(" 数据容灾")]),e._v(" "),a("p",[e._v("需要经常对数据数据（rdb文件）进行备份")]),e._v(" "),a("ol",[a("li",[e._v("使用corn job方式，定去备份rdb文件到某个文件夹")]),e._v(" "),a("li",[e._v("备份时间打上时间标签，使用find找到很早期的备份删除")]),e._v(" "),a("li",[e._v("定期把备份放到当前物理机之外的机器备份一份。")])]),e._v(" "),a("hr"),e._v(" "),a("h2",{attrs:{id:"redis主从-redis-replication"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis主从-redis-replication"}},[e._v("#")]),e._v(" redis主从（redis replication）")]),e._v(" "),a("h3",{attrs:{id:"redis主从配置方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis主从配置方式"}},[e._v("#")]),e._v(" redis主从配置方式")]),e._v(" "),a("p",[e._v("配饰redis主从备份操作很简单。在master中绑定服务器的ip，再在slave中设置slaveof即可")]),e._v(" "),a("p",[e._v("例如master:192.168.206.200 slave:192.168.206.201")]),e._v(" "),a("p",[e._v("配置如下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("#master配置\nbind 192.168.206.200\nport 6379\n\n#############################\n#slave 配置\nslaveof 192.168.206.200 6379\nslave-serve-stale-data yes #yes：设置master挂了之后slave仍然提供已经存在是数据。no：提示同步中\nslave-read-only yes # 设置slave只读，2.6之后默认是只读\n")])])]),a("p",[e._v("还有就是配置diskless ,但是此种方式在redis官方的说法上面是还在实验阶段。")]),e._v(" "),a("p",[e._v("master可选配置")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("min-slaves-to-write 3 # 配置至少有 3个slave连接正常的时候才同步数据\nmin-slaves-max-lag 10 # 最大延时少于 10s\n")])])]),a("p",[e._v("slave可选配置")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("slave-announce-ip 5.5.5.5 \nslave-announce-port 1234 \n")])])]),a("p",[e._v("此配置的目的在于向master申明自己的ip和端口")]),e._v(" "),a("blockquote",[a("p",[e._v("注意：当master节点挂了时候，我们从服务同步就会失败，一般使用sentinel做主从同步监控和切换")])]),e._v(" "),a("h3",{attrs:{id:"redis-主从特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-主从特性"}},[e._v("#")]),e._v(" redis 主从特性")]),e._v(" "),a("ol",[a("li",[e._v("redis的主从同步是异步进行的。redis 2.8开始，slave告知周期性（acknowledge ）同步流中处理的数据数量。")]),e._v(" "),a("li",[e._v("一个master可以有多个slave")]),e._v(" "),a("li",[e._v("slave也可以连接到其他的salve，形成一个流状（cascading-like）结构")]),e._v(" "),a("li",[e._v("redis的复制是非阻塞的，也就是说master在给一个或者多个同步数据的时候仍然可以处理客户端的请求")]),e._v(" "),a("li",[e._v("redis的复制在slave上面也是非阻塞的，slave可以利用之前的老数据处理请求，同步完成跟新老数据")]),e._v(" "),a("li",[e._v("复制可以用于可扩展性，以便为只读查询拥有多个从站（例如，可以将慢速O（N）操作卸载到从站），或简单地用于数据冗余")]),e._v(" "),a("li",[e._v("主从备份可以避免master把所有数据都持久化，可以设置master不持久化，让多个slave中的一台做持久化。但是这中设置一定要小心，重启master会是空数据，这个时候如果slave同步了，数据就丢失了。所有重启时要利用slave持久化的数据重启。")])]),e._v(" "),a("h3",{attrs:{id:"工作原理-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#工作原理-2"}},[e._v("#")]),e._v(" 工作原理")]),e._v(" "),a("p",[e._v("当建立一个从机器的时候，会尝试发从一条psync命令。主机会检测这是不是第一次链接。如果不是，主机就只会发送差异性数据。其他情况就是同步全部数据。\n当全部同步出发的时候，主机启动后台保存功能产生rdb文件，同时开启缓冲区接受新的写入。当保存工作完成后，然后把rdb文件发送给从机器，接着把缓冲区的指令也发给从机器，实现同步。")]),e._v(" "),a("p",[e._v("下一节，总结下如何建立高可用（High Availability）的redis服务")]),e._v(" "),a("p",[e._v(e._s(e.comment))])])}),[],!1,null,null,null);s.default=r.exports}}]);